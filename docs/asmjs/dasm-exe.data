#!/bin/sh

(cd ../../../; ./build)
   PROCESSOR 6502

; ====================================
; == ZERO PAGE ADDRESSING
; ====================================
; Magic value used by System Monitor
SYSMAGICADDRESS EQU $FFF0

;=====================================
;== USER SPACE STARTS HERE
;=====================================
   ORG $0600
   rts

;=====================================
;  The start of BIOS routines/ROM
;=====================================

   ORG $F000

; Reset routine, called as part of the; boot process.
; Cleanup routine from macro.h; (by Andrew Davie/DASM)

RESET: subroutine
; This magic value means we are NOT in
; BRK mode.  Used by the UI screen.
   LDA #$00
   STA SYSMAGICADDRESS

; Twiddle the bit to watch it change
; onscreen.  Watch the flags to see
; them go on and off
   CLD      ; CLEAR DECIMAL (D)
   SED      ; SET DECIMAL (D)
   CLD      ; SET DECIMAL (D)
   SED      ; CLEAR DECIMAL (D)

   sei      ; Allow interrupts
   cld      ; clear decimal flag
   ldx #0   ; Start counting at0
   txa      ; Copy to X
   tay      ; Copy to Y
.CleanStack:
   dex      ; DEC X. Wrap around to 255 on the first pass.
   txs      ; Set the stack pointer
   pha      ; And push a 0 there
   bne .CleanStack

   jsr  $0600  ; Start userland routines.
   brk

;===============================================================================
; free space check before End of Cartridge
;===============================================================================
 if (* & $FF)
    echo "------", [$FFF0 - *]d, "bytes free before end of ROM"
    ; align 256
 endif

 ; A magic area for system calls
 ; $A $FF EXIT
   ORG $FFF0
   .byte 00

_KSYSCALL:
   RTS

_KBRK:
   ; Set a magic flag to show we are in BRK mode
   PHA
   LDA #$FF
   STA SYSMAGICADDRESS
   PLA
   RTI

_KNMI:
   ; Set a magic flag to show we are in NMI mode
   PHA
   LDA #$FE
   STA SYSMAGICADDRESS
   PLA
   RTI

;===============================================================================
; Define End of Cartridge
;===============================================================================
   ORG $FFFA        ; set address to 6507 Interrupt Vectors

   .WORD _KNMI
   .WORD RESET
   .WORD _KBRK
   PROCESSOR 6502
   ORG $0600

; Calculator for 6502asm.com, Version 1.02, 2015.JUL.08 by Sid Liu
; It is slow in the 6502 emulator by JavaScript.
; The left top flash point is a busy indicator.
; The calculator supports keys: 'C', 'c', '0', '1', ..., '9', '+', '-' and '='.

main:               cld

                    jsr display

                    ; comparison loop for well response
getch_main:         lda $ff
                    cmp #67 ; 'C' for clear
                    beq store_main
                    cmp #99 ; 'c' for clear
                    beq store_main

                    cmp #43 ; '+'
                    beq store_main
                    cmp #45 ; '-'
                    beq store_main
                    cmp #61 ; '='
                    beq store_main

                    cmp #48 ; '0'
                    bmi getch_main
                    cmp #57 ; '9'
                    beq store_main
                    bpl getch_main

store_main:         sta key_main

                    ; clear key
                    lda #0
                    sta $ff

                    ; clear operand 2 by 'C' or 'c'
                    lda key_main
                    cmp #67
                    beq clear_main
                    cmp #99
                    beq clear_main
                    jmp operate_main

clear_main:         jsr clear
                    lda #61
                    sta _operator1
                    lda #0
                    sta still_main
                    sta standby_main

                    jsr display
                    jmp getch_main

                    ; operate operand 1 and operand 2
operate_main:       lda key_main
                    cmp #43 ; '+'
                    bne next1_main

                    sta _operator2

                    lda just_main
                    bne jump1_main

                    jsr operate

                    lda #1
                    sta standby_main
                    sta just_main
jump1_main:         jmp getch_main
                    
next1_main:         lda key_main
                    cmp #45 ; '-'
                    bne next2_main

                    sta _operator2

                    lda just_main
                    bne jump2_main

                    jsr operate

                    lda #1
                    sta standby_main
                    sta just_main
jump2_main:         jmp getch_main

next2_main:         lda key_main
                    cmp #61 ; '='
                    bne replace_main

                    sta _operator2

                    lda just_main
                    bne jump3_main

                    jsr operate
                    lda #61
                    sta _operator1

                    lda #1
                    sta standby_main
                    sta just_main
jump3_main:         jmp getch_main

replace_main:       lda standby_main
                    beq full_main
                    jsr move
                    jsr clear
                    lda #0
                    sta standby_main
                    jmp append_main

                    ; whether full of digits
full_main:          jsr length
                    lda $00
                    cmp #5
                    bne next3_main
                    jmp getch_main

next3_main:         lda still_main
                    beq append_main

                    ; shift digits
                    ldx #3

shift_main:         clc
                    lda _operand2,x
                    stx tmp_main
                    ldy tmp_main
                    iny
                    clc
                    sta _operand2,y
                    dex
                    txa
                    bpl shift_main

                    ; append digit
append_main:        lda #1
                    sta still_main
                    lda #0
                    sta just_main

                    lda key_main
                    sta _operand2

                    ; replace '0' with 's'
                    ldx #4

loop_main:          lda _operand2,x
                    cmp #48
                    beq space_main
                    cmp #115
                    beq next4_main
                    jmp display_main

space_main:         lda #115
                    sta _operand2,x

next4_main:         dex
                    beq display_main ; "XXXXY"
                    bpl loop_main

display_main:       jsr display
                    jmp getch_main

; global variables
_operand1:          .byte 48,115,115,115,115 ; 's' for space
_operator1:         .byte 61 ; '='
_operand2:          .byte 48,115,115,115,115
_operator2:         .byte 115

; local variables
key_main:           .byte 0
tmp_main:           .byte 0
still_main:         .byte 0 ; boolean, still editing flag
standby_main:       .byte 0 ; boolean, preparing to move and clear flag
just_main:          .byte 0 ; boolean, just operator key flag

operate:            ; operate operand 1 and operand 2

                    lda _operator1
                    cmp #43 ; '+'
                    beq add_operate
                    cmp #45 ; '-'
                    beq sub_operate
                    jmp end_operate

add_operate:        jsr add
                    jsr display
                    jmp end_operate

sub_operate:        jsr sub
                    jsr display

end_operate:        rts

add:                ; add operand 1 and operand 2

                    ldx #0

                    ldy #0
                    sty carry_add

loop1_add:          clc
                    lda _operand2,x
                    cmp #115
                    beq space1_add
                    sec
                    sbc #48
                    sta digit_add
                    jmp next1_add

space1_add:         lda #0
                    sta digit_add

next1_add:          clc
                    lda _operand1,x
                    cmp #115
                    beq space2_add
                    sec
                    sbc #48
                    jmp next2_add

space2_add:         lda #0

next2_add:          clc
                    adc digit_add
                    clc
                    adc carry_add

                    ldy #0
                    sty carry_add

                    cmp #10
                    bmi ascii_add

                    sec
                    sbc #10

                    ldy #1
                    sty carry_add

ascii_add:          clc
                    adc #48
                    clc
                    sta _operand2,x

                    inx
                    cpx #5
                    bmi loop1_add

                    ; replace '0' with 's'
                    ldx #4

loop2_add:          lda _operand2,x
                    cmp #48
                    bne end_add
                    lda #115
                    sta _operand2,x

                    dex
                    beq end_add ; "XXXXY"
                    bpl loop2_add

end_add:            rts

; local variables
digit_add:          .byte 0
carry_add:          .byte 0

sub:                ; sub operand 1 and operand 2


                    ldx #0

                    ldy #0
                    sty borrow_sub

loop1_sub:          clc
                    lda _operand2,x
                    cmp #115
                    beq space1_sub
                    sec
                    sbc #48
                    sta digit_sub
                    jmp next1_sub

space1_sub:         lda #0
                    sta digit_sub

next1_sub:          clc
                    lda _operand1,x
                    cmp #115
                    beq space2_sub
                    sec
                    sbc #48
                    jmp next2_sub

space2_sub:         lda #0

next2_sub:          sec
                    sbc digit_sub
                    sec
                    sbc borrow_sub

                    ldy #0
                    sty borrow_sub

                    cmp #0
                    bpl ascii_sub

                    clc
                    adc #10

                    ldy #1
                    sty borrow_sub

ascii_sub:          clc
                    adc #48
                    clc
                    sta _operand2,x

                    inx
                    cpx #5
                    bmi loop1_sub

                    ; replace '0' with 's'
                    ldx #4

loop2_sub:          lda _operand2,x
                    cmp #48
                    bne end_sub
                    lda #115
                    sta _operand2,x

                    dex
                    beq end_sub ; "XXXXY"
                    bpl loop2_sub

end_sub:            rts

; local variables
digit_sub:          .byte 0
borrow_sub:         .byte 0

length:             ; compute the length of operand 2
; input void; output $00;

                    ldx #0

loop_length:        cpx #5
                    beq end_length
                    clc
                    lda _operand2,x
                    inx
                    cmp #115
                    bne loop_length

                    dex

end_length:         stx $00
                    rts

move:               ; move operand 2 to operand 1
                    ; move operator 2 to operator 1

                    ldx #4

loop_move:          clc
                    lda _operand2,x
                    sta _operand1,x

                    dex
                    bpl loop_move

                    ; move operator 2 to operator 1
                    lda _operator2
                    sta _operator1

                    rts

clear:              ; clear operand 2

                    lda #4
                    sta count_clear

loop_clear:         lda #115
                    ldx count_clear
                    clc
                    sta _operand2,x
                    dec count_clear
                    lda count_clear
                    cmp #1
                    bpl loop_clear

                    lda #48
                    sta _operand2

                    rts

; local variables
count_clear:        .byte 0

display:            ; display operand 2

                    lda #4
                    sta count_display

loop_display:       lda count_display
                    sta $00
                    inc $00
                    lda #6
                    sta $01
                    jsr cmul
                    lda #32
                    sec
                    sbc $02
                    sta $00 ; 32-(count+1)*6
                    lda #22
                    sta $01
                    ldx count_display
                    clc
                    lda _operand2,x
                    sta $02
                    jsr draw

                    dec count_display
                    lda count_display
                    bpl loop_display 

                    rts

; local variables
count_display:      .byte 0

draw:               ; draw a digit
; input char x $00, char y $01,char digit $02; output void;

                    lda $00
                    sta x_draw
                    lda $01
                    sta y_draw

                    lda $02
                    cmp #115
                    bne digital_draw
                    lda #$ff ; -1 for space
                    sta value_draw
                    jmp init_draw
digital_draw:       sec
                    sbc #48
                    sta value_draw

init_draw:          lda #0
                    sta i_draw
                    sta j_draw

loop_draw:          ; converse white
                    lda i_draw
                    cmp #0
                    bne converse_draw
                    lda #1
                    sta $00
                    sta $01
                    lda #$01
                    sta $02
                    jsr pixel

                    ; converse black
converse_draw:      lda i_draw
                    cmp #3
                    bne start_draw
                    lda #1
                    sta $00
                    sta $01
                    lda #$00
                    sta $02
                    jsr pixel

start_draw:         lda value_draw
                    sta $00
                    bmi black_draw

                    lda #9
                    sta $01
                    jsr cmul
                    lda $02
                    clc
                    adc j_draw
                    tay
                    clc
                    lda font_draw,y ; byte=[font+value*9+j]
                    sta byte_draw

                    lda #1
                    sta mask_draw

                    ldx i_draw
shift_draw:         beq and_draw
                    asl mask_draw
                    dex
                    jmp shift_draw

and_draw:           lda mask_draw
                    and byte_draw
                    beq black_draw
white_draw:         lda #$01
                    sta color_draw
                    jmp pixel_draw
black_draw:         lda #$00
                    sta color_draw

pixel_draw:         lda i_draw
                    clc
                    adc x_draw
                    sta $00
                    lda j_draw
                    clc
                    adc y_draw
                    sta $01
                    lda color_draw
                    sta $02
                    jsr pixel

                    ; increase for next step
                    inc i_draw
                    lda i_draw
                    cmp #5
                    bpl next_draw
                    jmp loop_draw
next_draw:          lda #0
                    sta i_draw
                    inc j_draw
                    lda j_draw
                    cmp #9
                    bpl end_draw
                    jmp loop_draw

end_draw:           rts

; local variables
x_draw:             .byte 0
y_draw:             .byte 0
value_draw:         .byte 0
i_draw:             .byte 0
j_draw:             .byte 0
mask_draw:          .byte 0
byte_draw:          .byte 0
color_draw:         .byte 0

font_draw:          ; '0'~'9', 5x9
  .byte $0e,$11,$11,$13,$15,$19,$11,$11,$0e
  .byte $04,$06,$04,$04,$04,$04,$04,$04,$0e
  .byte $0e,$11,$10,$10,$08,$04,$02,$01,$1f
  .byte $0e,$11,$10,$10,$0e,$10,$10,$11,$0e
  .byte $08,$0c,$0a,$09,$09,$09,$1f,$08,$08
  .byte $1f,$01,$01,$01,$0f,$10,$10,$11,$0e
  .byte $0e,$11,$01,$01,$0f,$11,$11,$11,$0e
  .byte $1f,$11,$10,$10,$08,$08,$08,$04,$04
  .byte $0e,$11,$11,$11,$0e,$11,$11,$11,$0e
  .byte $0e,$11,$11,$11,$1e,$10,$10,$10,$0e

pixel:              ; draw a pixel
; pixel page memory address, m=512+y*32+x
; (or m0=y%8*32+x, m1=2+y/8)
; color: $00 is black, $01 is white
; input char x $00,y $01,color $02; output void; effect $60, $61

                    lda $00
                    sta x_pixel
                    lda $01
                    sta y_pixel
                    lda $02
                    sta color_pixel

                    lda y_pixel
                    sta $00
                    lda #8
                    sta $01
                    jsr cmod
                    lda $02
                    sta $00
                    lda #32
                    sta $01
                    jsr cmul
                    lda $02
                    clc
                    adc x_pixel
                    sta $60 ; m0

                    lda y_pixel
                    sta $00
                    lda #8
                    sta $01
                    jsr cdiv
                    lda $02
                    clc
                    adc #2
                    sta $61 ; m1

                    ldy #0
                    lda color_pixel
                    clc
                    sta ($60),y

                    rts

; local variables
x_pixel:            .byte 0
y_pixel:            .byte 0
color_pixel:        .byte 0

cmod:               ; char modulus
; c=a%b=a-a/b*b
; input char a $00,b $01; output char c $02;

                    LDA $00
                    STA a_cmod

                    JSR cdiv
                    LDA $02
                    STA $00
                    JSR cmul
                    LDA $02
                    STA p_cmod

                    LDA a_cmod
                    SEC
                    SBC p_cmod

                    STA $02

                    RTS

a_cmod:             .byte 0
p_cmod:             .byte 0 ; p=a/b*b

cmul:               ; char multiply
; c=a*b
; input char a $00,b $01; output char c $02;

                    LDA #0
                    LDX $01

loop_cmul:          BEQ take_cmul
                    CLC
                    ADC $00
                    DEX
                    JMP loop_cmul

take_cmul:          STA $02

                    RTS

cdiv:               ; char divide
; c=a/b
; input char a $00,b $01; output char c $02;

                    LDA #0
                    LDX #0
                    CLC

loop_cdiv:          CMP $00

                    BEQ take2_cdiv
                    BPL take1_cdiv

                    ADC $01
                    BCS take2_cdiv

                    INX
                    JMP loop_cdiv          

take1_cdiv:         DEX

take2_cdiv:         STX $02

                    RTS
   PROCESSOR 6502
   ORG $0600
   
; static noise

start: ldy #$ff
       ldx #$0
loop:  lda $fe
       sta $200,x
       and #$7
       sta $300,x
       and #$3
       sta $400,x
       and #$1
       sta $500,x
       inx
       dey
       bne loop
       rts
   PROCESSOR 6502
   ORG $0600
; A very simple example of
; self-modifying code
; and code entry points

  lda $fe
  sta $1001
  jmp $1000

   ORG $1000
  lda #$00
  sta $3ef
  jmp $600
     PROCESSOR 6502
   ORG $0600

start:
  ldx #0
c:
  lda bottombar,x
  cmp #$ff
  beq init
  sta $4e0,x
  sta $5e0,x
  inx
  jmp c
init:
  jsr initDraw
  lda #0
  sta $10 ; scrptr
  sta $11 ; txtptr
loop:
  jsr drawMain
  jsr putfont
  jsr scrollarea
  jmp loop

scrollarea:
  ldx #0
g:
  lda $521,x
  sta $520,x
  lda $541,x
  sta $540,x
  lda $561,x
  sta $560,x
  lda $581,x
  sta $580,x
  lda $5a1,x
  sta $5a0,x
  inx
  cpx #31
  bne g
  rts

putfont:
  lda $10 ; scrptr
  cmp #0
  bne noNext
  inc $11
  ldx $11
  lda scrolltext,x
  tax
  lda fontSize,x
  sta $10
noNext:
  dec $10
  ldx $11
  lda scrolltext,x
  cmp #$ff
  bne notResetText
  lda #0
  sta $10
  sta $11
  rts

notResetText:
  asl
  tax
  lda fontlookup,x
  sta $2
  inx
  lda fontlookup,x
  sta $3
  lda #<fonts
  clc
  adc $2
  sta $0
  lda #>fonts
  adc $3
  sta $1
  ldy $10
  lda ($00),y
  sta $53f
  tya
  clc
  adc #6
  tay
  lda ($00),y
  sta $55f
  tya
  clc
  adc #6
  tay
  lda ($00),y
  sta $57f
  tya
  clc
  adc #6
  tay
  lda ($00),y
  sta $59f
  tya
  clc
  adc #6
  tay
  lda ($00),y
  sta $5bf
  rts

initDraw:
  lda #<picture
  sta $20
  lda #>picture
  sta $21
  lda #$00
  sta $22
  lda #$02
  sta $23
  ldx #$0
  rts
drawMain:
  ldx #0
  lda ($20,x)
  cmp #$ff
  beq done
  sta ($22,x)
  inc $20
  lda $20
  cmp #$00
  bne n1
  inc $21
n1:
  inc $22
  lda $22 
  cmp #$00
  bne done
  lda $23
  cmp #$05
  beq done
  inc $23
done:
  rts

picture:
  .byte 0,0,0,0,0,0,0,0,0,$b,$b,$c,$f,$f,$f,$f
  .byte $f,$b,0,0,0,$b,$b,$c,$c,$f,$f,$b,0,0,0,0
  .byte 0,0,0,0,0,0,0,0,0,$b,$c,$c,$f,$c,$f,$f
  .byte $b,$b,$b,$b,$b,0,$b,$b,$c,$f,$f,$c,0,0,0,0
  .byte 0,0,0,0,0,0,0,$b,0,$c,$b,$f,$c,$f,$f,$c
  .byte $c,$b,0,$b,$c,$c,$c,$f,$f,1,$f,$c,$b,0,0,0
  .byte 0,0,0,0,0,0,0,0,$b,$b,$c,$c,$c,$f,$f,$f
  .byte $c,$c,$c,$c,$c,$c,$f,$c,$f,$f,$f,$f,$b,0,0,0
  .byte 0,0,0,0,0,0,0,$b,0,0,$b,$c,$c,$f,$f,$f
  .byte $f,$c,$f,$f,$f,$f,$f,$f,$f,1,$f,$f,$c,0,0,0
  .byte 0,0,0,0,0,0,0,0,0,$b,$b,$b,$c,$f,$f,1
  .byte $f,$f,$c,$f,$f,$f,1,$f,$f,$f,$f,$f,$f,0,0,0
  .byte 0,0,0,0,0,0,0,0,0,$b,$b,$b,$b,$c,$f,1
  .byte $f,$f,$f,$f,$f,$f,$f,$f,1,$f,$f,$f,$f,$b,0,0
  .byte 0,0,0,0,0,0,0,0,$b,0,$b,$c,$b,$c,$c,1
  .byte 1,$f,1,$f,1,$f,1,$f,$f,1,$f,$f,1,$b,0,0
  .byte 0,0,0,0,0,0,0,$b,$b,$b,$c,$c,$b,$c,$f,1
  .byte 1,1,$f,$f,1,$f,$f,1,$f,$f,$f,$f,1,$c,0,0
  .byte 0,0,0,0,0,0,0,$b,$b,$c,$c,$c,$b,$c,$c,$f
  .byte 1,1,1,$f,$f,1,$f,1,$f,1,$f,$f,1,$c,0,0
  .byte 0,0,0,0,0,$b,$b,$b,$c,$c,$c,$f,$c,$c,$f,$f
  .byte 1,1,1,1,$f,$f,$f,1,$f,1,$f,$f,$f,$f,0,0
  .byte 0,0,0,0,0,0,$b,$c,$c,$c,$f,$c,$f,$c,$f,$f
  .byte 1,1,1,1,1,$f,$f,1,$f,$f,$f,$f,1,$f,$b,0
  .byte 0,0,0,0,$b,$b,$b,$c,$c,$f,$c,$f,$f,$c,$f,$f
  .byte 1,1,1,1,1,$f,$f,$f,1,$f,$f,$f,1,$c,$b,$b
  .byte 0,0,0,0,$b,$b,$c,$f,$c,$f,$f,$f,$f,$f,$c,$f
  .byte 1,1,1,1,1,$f,$f,$f,1,$f,$f,$f,$f,$f,$b,$b
  .byte 0,0,0,0,$b,$c,$c,$c,$f,$f,$f,$f,$f,$f,$f,$f
  .byte $f,1,1,1,$f,$b,$f,$f,$f,1,$f,$f,$f,$f,$b,$b
  .byte 0,0,0,0,$b,$c,$c,$f,$c,$f,$f,$f,$f,$f,$f,$f
  .byte $f,$f,$f,$c,$b,$f,$f,1,$f,$f,$f,$f,$f,$f,$c,$b
  .byte 0,0,0,0,$b,$b,$c,$c,$f,$c,$f,$f,$f,$f,$f,$f
  .byte $c,$c,$b,$c,$c,$f,$f,1,$c,$c,$f,$f,$f,$f,$c,$b
  .byte 0,0,0,0,$b,$b,$c,$c,$c,$f,$f,$f,$f,$f,$f,$f
  .byte $f,$f,$f,$f,$f,1,$f,$c,$b,$f,$c,$f,$c,$f,$c,$b
  .byte 0,0,0,0,0,$b,$c,$c,$c,$c,$f,$f,$f,$f,$f,$f
  .byte $f,$f,$f,$f,$f,$c,$b,$c,$c,$c,$f,$f,$c,$f,$c,$c
  .byte 0,0,0,0,0,$b,$b,$c,$c,$c,$c,$c,$f,$f,$f,$f
  .byte $f,$f,$f,$c,$b,$b,$c,$c,$c,$f,$c,$f,$f,$f,$c,$b
  .byte 0,0,0,0,0,$b,$b,$b,$b,$c,$c,$f,$c,$f,$f,$f
  .byte $c,$c,$b,$b,$b,$c,$b,$b,$c,$c,$f,$c,$c,$f,$c,$c
  .byte 0,0,0,0,0,0,$b,$b,$c,$b,$c,$c,$c,$c,$c,$c
  .byte $b,$b,$b,$b,$c,$b,$b,$c,$c,$f,$f,$f,$c,$c,$c,$b
  .byte 0,0,0,0,0,0,0,0,$b,$b,$b,$c,$c,$c,$c,$c
  .byte $c,$c,$b,$b,$b,$b,$c,$c,$f,$f,$f,$c,$c,$c,$c,$c
  .byte $ff


fontSize:
  .byte 5,5,5,5,5,5,5,5 ;abcdefgh
  .byte 2,5,5,5,6,6,5,5 ;ijklmnop
  .byte 6,5,5,4,5,6,6,6 ;qrstuvwx
  .byte 6,5,2,3         ;yz.[SPACE]

;
; a=0, b=1, c=2, d=3....
;

scrolltext:
  .byte 0

  .byte 14,13,11,24,27           ; "only "
  .byte 03,04,15,19,07,27        ; "depth "
  .byte 12,0,10,4,18,27          ; "makes "
  .byte 8,19,27                  ; "it "
  .byte 15,14,18,18,8,1,11,4     ; "possible"
  .byte 26,26,26                 ; "..."
  .byte 19,7,8,18,27             ; "this "
  .byte 8,18,27                  ; "is "
  .byte 19,7,4,27                ; "the "
  .byte 5,8,17,18,19,27          ; "first "
  .byte 3,4,12,14,27             ; "demo "
  .byte 12,0,3,4,27              ; "made "
  .byte 8,13,27                  ; "in "
  .byte 19,7,8,18,27             ; "this "
  .byte 4,13,21,26,26,26,26,27   ; "env.... "
  .byte 7,14,15,4,27             ; "hope "
  .byte 24,14,20,27              ; "you "
  .byte 11,8,10,4,27             ; "like "
  .byte 8,19,26,26,26,27,27      ; "it...  "
  .byte 22,22,22,26              ; "www."
  .byte 3,4,15,19,7,26           ; "depth."
  .byte 14,17,6,27,27,27,27,27   ; "org     "

  .byte $ff                      ; end of text

fontlookup:
  .byte $00,$00 ;a
  .byte $20,$00 ;b
  .byte $40,$00 ;c
  .byte $60,$00 ;d
  .byte $80,$00 ;e
  .byte $a0,$00 ;f
  .byte $c0,$00 ;g
  .byte $e0,$00 ;h
  .byte $00,$01 ;i
  .byte $20,$01 ;j
  .byte $40,$01 ;k
  .byte $60,$01 ;l
  .byte $80,$01 ;m
  .byte $a0,$01 ;n
  .byte $c0,$01 ;o
  .byte $e0,$01 ;p
  .byte $00,$02 ;q
  .byte $20,$02 ;r
  .byte $40,$02 ;s
  .byte $60,$02 ;t
  .byte $80,$02 ;u
  .byte $a0,$02 ;v
  .byte $c0,$02 ;w
  .byte $e0,$02 ;x
  .byte $00,$03 ;y
  .byte $20,$03 ;z
  .byte $40,$03 ;.
  .byte $60,$03 ;" "

fonts:
  .byte 0,1,1,0,0,0
  .byte 1,0,0,1,0,0
  .byte 1,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,0

  .byte 0,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 0,0

  .byte 0,1,1,0,0,0
  .byte 1,0,0,1,0,0
  .byte 0,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,0,0,0
  .byte 0,0

  .byte 0,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 0,0

  .byte 1,1,1,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 0,0,0,1,0,0
  .byte 1,1,1,1,0,0
  .byte 0,0

  .byte 1,1,1,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,0

  .byte 1,1,1,0,0,0
  .byte 0,0,0,1,0,0
  .byte 1,1,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,1,1,0,0,0
  .byte 0,0

  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,0

  .byte 1,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 0,0

  .byte 1,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,0,0,0
  .byte 0,0

  .byte 1,0,0,1,0,0
  .byte 0,1,0,1,0,0
  .byte 0,0,1,1,0,0
  .byte 0,1,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,0

  .byte 0,0,0,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,0,0,1,0,0
  .byte 1,1,1,1,0,0
  .byte 0,0

  .byte 1,0,0,0,1,0
  .byte 1,1,0,1,1,0
  .byte 1,0,1,0,1,0
  .byte 1,0,0,0,1,0
  .byte 1,0,0,0,1,0
  .byte 0,0

  .byte 1,0,0,0,1,0
  .byte 1,0,0,1,1,0
  .byte 1,0,1,0,1,0
  .byte 1,1,0,0,1,0
  .byte 1,0,0,0,1,0
  .byte 0,0

  .byte 0,1,1,0,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,0,0,0
  .byte 0,0

  .byte 0,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,0,0,1,0,0
  .byte 0,0

  .byte 0,1,1,0,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,0,1,0,0
  .byte 1,0,1,0,0,0
  .byte 0,0

  .byte 0,1,1,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,1,1,1,0,0
  .byte 0,1,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 0,0

  .byte 1,1,1,0,0,0
  .byte 0,0,0,1,0,0
  .byte 0,1,1,0,0,0
  .byte 1,0,0,0,0,0
  .byte 0,1,1,1,0,0
  .byte 0,0

  .byte 1,1,1,0,0,0
  .byte 0,1,0,0,0,0
  .byte 0,1,0,0,0,0
  .byte 0,1,0,0,0,0
  .byte 0,1,0,0,0,0
  .byte 0,0

  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,0,0,1,0,0
  .byte 1,1,1,0,0,0
  .byte 0,0

  .byte 1,0,0,0,1,0
  .byte 1,0,0,0,1,0
  .byte 1,0,0,0,1,0
  .byte 0,1,0,1,0,0
  .byte 0,0,1,0,0,0
  .byte 0,0

  .byte 1,0,0,0,1,0
  .byte 1,0,0,0,1,0
  .byte 1,0,1,0,1,0
  .byte 1,1,0,1,1,0
  .byte 1,0,0,0,1,0
  .byte 0,0

  .byte 1,0,0,0,1,0
  .byte 0,1,0,1,0,0
  .byte 0,0,1,0,0,0
  .byte 0,1,0,1,0,0
  .byte 1,0,0,0,1,0
  .byte 0,0

  .byte 1,0,0,0,1,0
  .byte 0,1,0,1,0,0
  .byte 0,0,1,0,0,0
  .byte 0,0,1,0,0,0
  .byte 0,0,1,0,0,0
  .byte 0,0

  .byte 1,1,1,1,0,0 ; z
  .byte 1,0,0,0,0,0
  .byte 0,1,1,0,0,0
  .byte 0,0,0,1,0,0
  .byte 1,1,1,1,0,0
  .byte 0,0

  .byte 0,0,0,0,0,0 ; .
  .byte 0,0,0,0,0,0
  .byte 0,0,0,0,0,0
  .byte 0,0,0,0,0,0
  .byte 1,0,0,0,0,0
  .byte 0,0

  .byte 0,0,0,0,0,0 ; " "
  .byte 0,0,0,0,0,0
  .byte 0,0,0,0,0,0
  .byte 0,0,0,0,0,0
  .byte 0,0,0,0,0,0
  .byte 0,0

bottombar:
  .byte $b,$9,$b,9,8,9,8,$a,8,$a,7,$a,7,1,7,1,1
  .byte 7,1,7,$a,7,$a,8,$a,8,9,8,9,$b,9,$b
  .byte $ff

   PROCESSOR 6502
   ORG $0600
; Screen patterns 
;
; Quick hack - code could obviously be improved but this produces some fun and weird patterns. 
;
; Great job on the emulator!
; It reminds me of my Ohio Scientific Challenger 1P...
;
; Pete Laing

; Try hitting random keys on keyboard for
 
      ldy #$00   ;  clear y index
      lda $fe    ;  get a random number, temporarily save in X
loop: tax        ;  
      lda $ff    ;  get key from Keyboard
      pha        ;  save to stack as we mangle it displaying 
      sta $500   ;  display low nybble
      clc        ;  clear carry so we rotate in 0\'s
      ror        ;  now get low nybble
      ror
      ror
      ror 
      sta $501   ; display that too
      pla        ; get back original key from stack
                 ; not necessary if we swapped order above...   
                 
      and #$0f   ; extract it\'s least significant nybble
      sta $01    ; and save it on zero page
      txa        ; get back random number
      rol        ; shift to high nybble
      rol
      rol
      rol        ; Try eor $00 below and hit p y o x f multiple times
      eor $01    ; Try 1 and hit a, s, d, f for fun too   
      sta $200,y ; store to screen 
      sta $300,y 
      sta $400,y
      dey        
      sty $540   ; show y index 
;     jsr delay ; slow things down if you want
      jmp loop

delay: pha       ; save regs we use for loop
       txa
       pha       
       ldx #$ff    ; count=255 
loop2: dex         ; count=count-1
       lda $fe     ; get a random
       bne loop2   ; if count!=0 back to loop2
       pla         ; restore regs
       tax
       pla
       rts         ; return from subroutine
   PROCESSOR 6502
   ORG $0600
   
; Conway\'s Game of Life
; http://rosettacode.org/wiki/Conway\'s_Game_of_Life
; Submitted by Anonymous

randfill:   stx $01          ;$200 for indirect
            ldx #$02         ;addressing
            stx $02
randloop:   lda $fe          ;generate random
            and #$01         ;pixels on the
            sta ($01),Y      ;screen
            jsr inc0103
            cmp #$00
            bne randloop
            lda $02
            cmp #$06
            bne randloop
 
 
clearmem:   lda #$df         ;set $07df-$0a20
            sta $01          ;to $#00
            lda #$07
            sta $02
clearbyte:  lda #$00
            sta ($01),Y
            jsr inc0103
            cmp #$20
            bne clearbyte
            lda $02
            cmp #$0a
            bne clearbyte
 
 
starttick:
copyscreen: lda #$00         ;set up source
            sta $01          ;pointer at
            sta $03          ;$01/$02 and
            lda #$02         ;dest pointer
            sta $02          ;at $03/$04
            lda #$08
            sta $04
            ldy #$00
copybyte:   lda ($01),Y      ;copy pixel to
            sta ($03),Y      ;back buffer
            jsr inc0103      ;increment pointers
            cmp #$00         ;check to see
            bne copybyte     ;if we\'re at $600
            lda $02          ;if so, we\'ve
            cmp #$06         ;copied the
            bne copybyte     ;entire screen
 
 
conway:     lda #$df         ;apply conway rules
            sta $01          ;reset the pointer
            sta $03          ;to $#01df/$#07df
            lda #$01         ;($200 - $21)
            sta $02          ;($800 - $21)
            lda #$07
            sta $04
onecell:    lda #$00         ;process one cell
            ldy #$01         ;upper cell
            clc
            adc ($03),Y
            ldy #$41         ;lower cell
            clc
            adc ($03),Y
chkleft:    tax              ;check to see
            lda $01          ;if we\'re at the
            and #$1f         ;left edge
            tay
            txa
            cpy #$1f
            beq rightcells
leftcells:  ldy #$00         ;upper-left cell
            clc
            adc ($03),Y
            ldy #$20         ;left cell
            clc
            adc ($03),Y
            ldy #$40         ;lower-left cell
            clc
            adc ($03),Y
chkright:   tax              ;check to see
            lda $01          ;if we\'re at the
            and #$1f         ;right edge
            tay
            txa
            cpy #$1e
            beq evaluate
rightcells: ldy #$02         ;upper-right cell
            clc
            adc ($03),Y
            ldy #$22         ;right cell
            clc
            adc ($03),Y
            ldy #$42         ;lower-right cell
            clc
            adc ($03),Y
evaluate:   ldx #$01         ;evaluate total
            ldy #$21         ;for current cell
            cmp #$03         ;3 = alive
            beq storex
            ldx #$00
            cmp #$02         ;2 = alive if
            bne storex       ;c = alive
            lda ($03),Y
            and #$01
            tax
storex:     txa              ;store to screen
            sta ($01),Y
            jsr inc0103      ;move to next cell
conwayloop: cmp #$e0         ;if not last cell,
            bne onecell      ;process next cell
            lda $02
            cmp #$05
            bne onecell
            jmp starttick    ;run next tick
 
 
inc0103:    lda $01          ;increment $01
            cmp #$ff         ;and $03 as 16-bit
            bne onlyinc01    ;pointers
            inc $02
            inc $04
onlyinc01:  inc $01
            lda $01
            sta $03
            rts
   PROCESSOR 6502
   ORG $0600
;
; DISCO DISCO
; submitted by Anonymous
 
start:
 inx
 txa
 sta $200,y
 sta $300,y
 sta $400,y
 sta $500,y
 iny
 tya
 cmp 16
 bne do
 iny
 jmp start
do:
 iny
 iny
 iny
 iny
 jmp start

   PROCESSOR 6502
   ORG $0600

; This code is non-functional in the original emulator
; it doesn't like the 
;  eor ($0,x)
; line
; So I can't tell what it does or if this one does the same.

; Sierpinski
; Submitted by Anonymous

start:
  lda #$e1
  sta $0
  lda #$01
  sta $1
  ldy #$20

write:
  ldx #$00
  eor ($0,x)
  sta ($0),y

  inc $0
  bne write
  inc $1
  ldx $1
  cpx #$06
  bne write

  rts
   PROCESSOR 6502
   ORG $0600
;RLE compressed full screen logo
;by Thomas

;set up our pointers
  lda #<logo ;for the logo
  sta $0
  lda #>logo
  sta $1

  lda #0 ;and to the screen area
  sta $2
  lda #2
  sta $3

loop: ;main loop
  lda ($0),y ;load the repeat count
  cmp #0 ;if it is zero
  beq done ;we\'re done
  tax ;put the repeat count in x
  iny
  lda ($0),y ;now load the byte
  iny

rleloop:
  jsr draw ;go draw our current pixel using the color in a
  dex
  cpx #0 ;if x is zero
  beq loop ;we are done with this rle block
  jmp rleloop ;otherwise, output another pixel

draw:
  sty $4 ;store the current y and load the other y for this routine
  ldy $5
  sta ($2),y ;actually plot the pixel
  iny ;get ready for the next pixel
  cpy #00 ;if y has wrapped around
  beq next ;increment the address and reset y
  sty $5 ;save y and load the old one
  ldy $4
  rts

next:
  ldy #0 ;reset y
  inc $03 ;but increment the screen pointer
  sty $5 ;save y and load the old one
  ldy $4
  rts

done:
  rts ;tries to return, causes a stack empty error and halts the program

;RLE logo data
;each  .byte is one RLE block
;RLE blocks are encoded as repeat count and then byte
;a count of zero indicates end of stream
logo:
  .byte 45,1 ;for example, this says repeat 1 45 times
  .byte 7,6 ;and repeat 6 7 times
  .byte 22,1
  .byte 11,6
  .byte 19,1
  .byte 13,6
  .byte 18,1
  .byte 14,6
  .byte 17,1
  .byte 15,6
  .byte 16,1
  .byte 16,6
  .byte 15,1
  .byte 17,6
  .byte 14,1
  .byte 12,6
  .byte 4,1
  .byte 2,6
  .byte 14,1
  .byte 10,6
  .byte 8,1
  .byte 11,6
  .byte 2,1
  .byte 9,6
  .byte 10,1
  .byte 10,6
  .byte 3,1
  .byte 8,6
  .byte 11,1
  .byte 9,6
  .byte 4,1
  .byte 8,6
  .byte 11,1
  .byte 8,6
  .byte 4,1
  .byte 8,6
  .byte 12,1
  .byte 7,6
  .byte 5,1
  .byte 8,6
  .byte 12,1
  .byte 6,6
  .byte 6,1
  .byte 8,6
  .byte 12,1
  .byte 5,6
  .byte 7,1
  .byte 8,6
  .byte 12,1
  .byte 5,2
  .byte 7,1
  .byte 8,6
  .byte 12,1
  .byte 6,2
  .byte 6,1
  .byte 8,6
  .byte 12,1
  .byte 7,2
  .byte 5,1
  .byte 8,6
  .byte 12,1
  .byte 8,2
  .byte 5,1
  .byte 8,6
  .byte 11,1
  .byte 9,2
  .byte 4,1
  .byte 9,6
  .byte 10,1
  .byte 10,2
  .byte 4,1
  .byte 9,6
  .byte 9,1
  .byte 11,2
  .byte 3,1
  .byte 10,6
  .byte 7,1
  .byte 1,6
  .byte 15,1
  .byte 17,6
  .byte 15,1
  .byte 17,6
  .byte 16,1
  .byte 16,6
  .byte 17,1
  .byte 15,6
  .byte 19,1
  .byte 13,6
  .byte 20,1
  .byte 12,6
  .byte 23,1
  .byte 9,6
  .byte 43,1
  .byte 0 ;end of stream marker
; submitted by Anonymous

   PROCESSOR 6502
   ORG $0600

 ldx #0
 ldy #0
 ;init screen
 lda #0
 sta $0
 lda #2
 sta $1
loop:
 lda colors,x
 bpl ok
 inc $0
 ldx #0
 lda colors,x
ok:
 inx
 sta ($0),y
 iny
 bne ok2
 inc $1
ok2:
 jmp loop

colors:
 .byte 0,2,0,2,2,8,2,8,8,7,8,7,7,1,7,1,1,7,1,7,7,8,7,8,8,2,8,2,2,0,2,0
 .byte 2,2,8,2,8,8,7,8,7,7,1,7,1,1,1,1,1,1,1,1,7,1,7,7,8,7,8,8,2,8,2,2,$ff
   PROCESSOR 6502
   ORG $0600
; We all love zookeeper !!!! 
; Submitted by Anonymous

  ldx #0 
  lda #0 
hupsu: 
  sta $200,x 
  sta $300,x 
  sta $400,x 
  sta $500,x 
  bne hupsu 


  lda #1 
  ldx #0 
fill: 
  txa 
  tay 
  lda seko,x 
  tax 
  lda kuva,x 
  sta $200,x 
  lda kuva_0,x 
  sta $300,x 
  lda kuva_1,x 
  sta $400,x 
  lda kuva_2,x 
  sta $500,x 
  tya 
  tax 
  inx 
  bne fill 

  rts 

seko: 
  .byte 46,93,219,97,168,170,196,63,204,201,206 
  .byte 56,238,25,2,186,209,191,138,226,80,128 
  .byte 58,171,81,115,42,44,102,193,69,231,107 
  .byte 78,5,218,103,11,13,221,130,149,16,227 
  .byte 105,213,232,182,17,255,27,190,205,137,192 
  .byte 222,233,94,52,229,96,18,220,202,122,166 
  .byte 43,153,131,246,177,4,70,22,7,86,173 
  .byte 141,151,164,32,143,40,156,185,121,132,165 
  .byte 62,249,252,139,154,251,85,236,12,134,245 
  .byte 184,39,195,119,242,244,162,74,1,77,51 
  .byte 33,75,35,76,34,10,89,47,189,237,71 
  .byte 159,9,38,101,180,116,147,140,183,157,123 
  .byte 14,19,126,199,100,45,241,28,125,210,155 
  .byte 41,254,31,144,55,247,111,95,57,53,223 
  .byte 152,108,203,36,214,37,113,200,66,67,197 
  .byte 29,250,20,212,68,87,207,163,145,211,48 
  .byte 136,24,98,215,169,83,124,224,181,187,142 
  .byte 84,240,54,110,234,59,243,79,50,30,114 
  .byte 6,178,0,172,148,146,179,120,60,225,65 
  .byte 230,208,15,72,117,248,198,106,129,92,127 
  .byte 175,160,49,216,176,133,64,109,112,82,90 
  .byte 235,104,158,194,8,161,167,88,91,174,23 
  .byte 73,118,150,3,99,61,217,26,239,21,253 
  .byte 135,188,228 

kuva: 
  .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 
  .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1 
  .byte 1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1 
  .byte 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1 
  .byte 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1 
  .byte 1,1,1,1,0,0,11,11,11,0,0,0,0,0,0,1,0,0,0,11,11,11,0,0,0,0,0,1,1,1,1,1 
  .byte 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1 
  .byte 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1 
kuva_0: 
  .byte 
  .byte 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1 
  .byte 1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1 
  .byte 1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1 
  .byte 1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,15,0,0,0,1,1 
  .byte 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1 
  .byte 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1 
  .byte 1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,15,0,0,0,1,1 
  .byte 1,0,0,0,1,0,0,0,0,1,1,1,0,0,0,1,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,1 
kuva_1: 
  .byte 
  .byte 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1 
  .byte 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,15,0,0,0,1,1 
  .byte 1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,15,1,1,1,1,1,1,1,1,1,1,15,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,15,1,1,1,1,1,1,1,1,1,1,15,0,0,0,1,1 
kuva_2: 
  .byte 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,0,15,15,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,1,1,1,1,1,1,1,1,1,15,15,0,15,15,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,15,1,1,1,1,1,1,1,1,15,15,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1 
  .byte 1,0,0,0,0,15,15,15,15,15,15,1,15,1,1,1,1,1,15,1,15,15,15,1,1,15,0,0,0,0,1,1 
  .byte 1,0,0,0,0,15,15,15,15,15,15,1,15,1,1,1,1,1,15,1,15,15,15,1,1,15,0,0,0,0,1,1 
  .byte 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1 
  .byte 1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
   PROCESSOR 6502
   ORG $0600
; By DMSC - daniel.serpell@gmail.com
;
; This demo was programmed in ACME:
;     http://www.esw-heim.tu-clausthal.de/~marco/smorbrod/acme/
;
; If you want the source code, send me an email :-)
;

 .byte  76, 94, 11,133, 32,162,  8,160,  8,145, 16,136,208,251,165, 16
 .byte  24,105, 32,133, 16,165, 17,105,  0,133, 17,165, 32,202,208,231
 .byte  96,230, 48,165, 48, 41, 63,133, 48,170,189,106,  6,170,189,  8
 .byte   3,105,  1, 41,  3,157,  8,  3,138, 73,231,170,189,  0,  2,105
 .byte   1, 41,  3,157,  0,  2,165, 48, 73, 63,170,189,106,  6, 73,224
 .byte 170,189,  8,  2,105,  1, 41,  3,157,  8,  2,138, 73,231,170,189
 .byte   0,  3,105,  1, 41,  3,157,  0,  3, 96,224,192,160,128, 96,225
 .byte  64,193,161,226,129, 32,194, 97,162,227,195,130,228, 65,163,196
 .byte  98,229,131,164,197,230,231,132,165,198, 99, 66, 33,  0,199,166
 .byte 133,100,167, 67,134,101,135, 34, 68,102,103, 69, 35, 70, 71, 36
 .byte   1, 37, 38, 39,  2,  3,  4,  5,  6,  7,166, 48,189,198,  6,170
 .byte 254, 24,  3, 73,  7,170,254, 16,  3, 73,231,170,254, 24,  2, 73
 .byte   7,170,254, 16,  2, 96,  0, 32,  1, 33, 64,  2, 65, 34, 96, 66
 .byte   3, 97, 35, 98, 67,128,  4,129, 36, 99,130, 68,160,  5,161,131
 .byte 100, 37,162, 69,132,192,163,101,  6,193, 38,194, 70,164,133,195
 .byte 102,224,  7,225, 39,165,226,196,134, 71,227,103,197,166,228,135
 .byte 198,229,167,230,199,231,166, 49,189, 21,  7,170,189,  0,160,157
 .byte   0,  5,230, 49, 96,195,227,194,162,228, 97,226,128,129,130,225
 .byte  64,161,163,224, 96,160,193,196, 32, 98,192, 65,  0,131,229,164
 .byte  33, 99,197, 66,132,  1,230, 34,165, 67,100,198,  2,  3, 68,  6
 .byte  35,133,166,  5,101,  4,199,  7, 36,231, 69,134,167, 37, 38,102
 .byte 135, 70,232, 71, 39,103,136,200,168,  8, 11, 10,169,233,104,  9
 .byte  12,137,201, 13, 40, 44, 72, 43,170, 42, 45, 41,105, 73,202, 14
 .byte 138,234, 74, 75,106,203, 76,171, 46, 77,235,107,139, 15,108,172
 .byte 174,140,173,141,142,204,109,206,207,205, 78,175, 47,236,239,143
 .byte 237,238,110,240,241,111,208, 16, 79,176,209,242, 48,144,243, 80
 .byte 177,244,112,210, 17, 49,178,179, 52, 53,147, 18, 81,211,145, 19
 .byte 146, 51, 85,180, 20, 54,113,148, 22, 50, 84,212, 21, 55,115,245
 .byte  83,114,116, 23, 82, 86, 88, 89, 87,118,117,119,149,213, 56, 57
 .byte 181,214, 90,121,122,150,151,182,183,215,246, 58,120,247, 24,153
 .byte 184,152,216, 25, 26, 59, 91,248,123,185, 27, 60,217,154, 28, 92
 .byte 249, 29,155,186, 61,218, 93,124,250,187, 30,251, 62,156, 94,125
 .byte 219,188, 31,252,254,220,253, 63,126,255,157,221, 95,159,191,222
 .byte 127,189,223,158,190,165, 66, 41,224,208, 72,165, 66, 24,105,  1
 .byte  41, 31,133, 66,165, 67,240,  7,198, 67,169,  0, 76, 97,  8,198
 .byte  69,240,247, 16, 37,166, 64,230, 64,189,177,  9, 16, 15, 41,127
 .byte 133, 67, 73,127,208,228,169,  1,133, 70, 76, 42,  8,170,189,117
 .byte   8,133, 69,234,234,189,181,  8,133, 65,166, 65,230, 65,189,245
 .byte   8,133, 68,165, 66, 24,105,224,133, 66,166, 66,169,  1,102, 68
 .byte  42,157,  0,160, 96,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2
 .byte   3,  2,  3,  3,  3,  3,  3,  1,  2,  3,  1,  5,  3,  3,  3,  3
 .byte   3,  2,  2,  3,  3,  5,  4,  3,  3,  5,  4,  4,  4,  3,  3,  4
 .byte   4,  1,  3,  4,  3,  5,  5,  5,  4,  5,  4,  4,  3,  4,  4,  7
 .byte   4,  4,  4,  2,  1,  0,  3,  6,  9, 12, 15, 18, 21, 24, 27, 30
 .byte  32, 35, 35, 38, 40, 43, 46, 49, 50, 52,  4, 55, 55, 60, 63, 65
 .byte  68, 71, 73, 75, 78, 78, 33, 83, 86, 89, 94, 98,102,106,109,112
 .byte 116, 94,120,123,127,130,134,139,144,148,153,157,161,164,167,171
 .byte 178,171,182,186,  5, 56, 68, 56, 36,124,  4, 76, 84, 36, 68, 84
 .byte  40, 24, 40,124,100, 84, 88, 56, 84, 72, 76, 80, 96, 40, 84, 40
 .byte  36, 84, 56, 44, 28,124, 36, 24, 24, 36,124, 24, 52, 16, 60, 80
 .byte  24, 37, 30,124, 32, 28,188,  1,190,124, 24, 36, 60, 32, 28, 32
 .byte  28, 24, 36, 24, 63, 36, 24, 36, 63, 60, 16, 32, 52, 44,120, 36
 .byte  56,  4, 60, 56,  4, 56,  4, 56, 57,  6, 56, 44, 52, 36, 12, 48
 .byte 208, 48, 12,252,164,164, 88,120,132,132, 72,252,132,132,120,252
 .byte 164,132,252,160,128,120,132,164, 56,252, 32, 32,252,  8,  4,248
 .byte 252, 48, 80,140,252,  4,  4,252, 64, 60, 64,252, 64, 48,  8,252
 .byte 120,132,132,132,120,252,144,144, 96,120,132,134,133,120,252,144
 .byte 144,108, 68,164,164,152,128,252,128,248,  4,  4,248,  4,  8,240
 .byte 224, 28, 16,224, 28, 16,224,204, 48, 48,204,140,148,164,196,  0
 .byte   0,133, 41, 10, 28, 29, 63, 63, 63,136, 15, 10, 28, 29, 14, 27
 .byte  63, 63, 63,132, 55, 17, 18, 28, 62, 18, 28, 62, 10,136, 27, 14
 .byte  10, 21, 21, 34,143, 15, 10, 28, 29,142, 39, 40, 48, 50,149,145
 .byte  10, 23, 13, 62, 23, 24, 32,136, 28, 24, 22, 14,136, 11, 14, 10
 .byte  30, 29, 18, 15, 30, 21,128, 14, 15, 15, 14, 12, 29, 28, 63, 63
 .byte  63,144,159,255, 55, 17, 18, 28, 62, 18, 28, 62, 10, 21, 21,129
 .byte  15, 24, 27, 62, 23, 24, 32,136, 11, 34, 14, 63, 63, 63,141, 63
 .byte  63, 63, 11, 34, 14,150,159,143, 11, 34, 62, 39, 48, 54, 38,  2
 .byte   0,  0,  7, 63,  5, 63,  2,  9, 11, 34, 62, 39, 48, 54, 38,  2
 .byte   0,  0,  7, 63,  5, 63,  2,  9, 11, 34, 62, 39, 48, 54, 38,  2
 .byte   0,  0,  7, 63,  5, 63,  2,  9,143,159,255,169,  0,133, 42,169
 .byte   1,133, 44,133, 45,169,  0,133, 32,169,160,133, 33,165, 42,133
 .byte  43,162, 15,160, 15,145, 32, 24,101, 44,230, 44,136, 16,246,165
 .byte  32, 24,105, 32,133, 32,165, 33,105,  0,133, 33,169,  1,133, 44
 .byte 165, 43, 24,101, 45,133, 43,230, 45,202, 16,215,169,  0,133, 32
 .byte 169,160,133, 33,169,224,133, 34,169,  3,133, 35,169,  0,133, 36
 .byte 169,  4,133, 37,169,240,133, 38,169,  3,133, 39,169, 16,133, 40
 .byte 169,  4,133, 41,169, 15,133, 46,160, 15,177, 32, 74, 74, 74, 74
 .byte 170,189, 62, 11,209, 34,240, 18,145, 34,145, 36,170,152, 73, 15
 .byte 168,138,145, 38,145, 40,152, 73, 15,168,136, 16,221,165, 32, 24
 .byte 105, 32,133, 32,165, 33,105,  0,133, 33,165, 34, 24,105,224,133
 .byte  34,165, 35,105,255,133, 35,165, 36, 24,105, 32,133, 36,165, 37
 .byte 105,  0,133, 37,165, 38, 24,105,224,133, 38,165, 39,105,255,133
 .byte  39,165, 40, 24,105, 32,133, 40,165, 41,105,  0,133, 41,198, 46
 .byte  16,150,230, 42,165, 42, 41, 63,240,  3, 76, 95, 10, 96,  0, 11
 .byte  12, 15,  1, 15, 12, 11,  0, 11, 12, 15,  1, 15, 12, 11,  0, 11
 .byte  12, 15,  1, 15, 12, 11,  0, 11, 12, 15,  1, 15, 12, 11,169,  1
 .byte 162,255,134, 16,162,  1,134, 17, 32,  3,  6,169,  2,162,  7,134
 .byte  16,162,  2,134, 17, 32,  3,  6,169,  3,162,  7,134, 16,162,  3
 .byte 134, 17, 32,  3,  6,169, 31,133, 66,169,  0,133, 70,133, 67,133
 .byte  64,169,  1,141,109,  8,169,  0,141,114,  8,169,160,141,115,  8
 .byte 169, 63,133, 48,169,128,133, 49,169,  3,141,109,  8,169,  0,170
 .byte 157,  0,160,232,208,250, 32, 33,  6, 32,170,  6, 32,  6,  7, 32
 .byte  21,  8,165, 66, 73, 31,208, 13,173,109,  8, 24,105,  2, 41,  3
 .byte 105,  3,141,109,  8,165, 49,208,221,173, 17,  7, 73,  1,141, 17
 .byte   7,165, 70,240,209, 32, 29, 12, 32, 91, 10,169, 31,133, 66,169
 .byte   0,133, 70,133, 67,141,109,  8,169,  0,141,114,  8,169,  3,141
 .byte 115,  8, 32, 29, 12, 32, 21,  8,165, 66, 73, 31,208,247,173,115
 .byte   8, 73,  7,141,115,  8,165, 70,240,235, 76, 94, 11,169,  0,170
 .byte 157,  0,  2,157,  0,  3,157,  0,  4,157,  0,  5,232,208,241, 96
 
   PROCESSOR 6502
; This is just a simple example
; to show how you can implement
; "splash screens" to your programs
;
; Notice that you don't have to
; press the "Run" button to see
; the results.
;
; This makes a nice "cover art" to
; your program.
;
; (Any takers on the Last Ninja game? ;))

    org $0600
    rts ; just exit nicely

    org $02e0
    .byte 0,0,0,0,9,9,15,15,8,2,8,9,0,0,0,0
    .byte 0,0,0,9,9,8,2,8,15,9,9,9,0,0,0,0
    .byte 0,0,0,0,0,0,0,0,9,8,15,15,8,15,8,9
    .byte 9,15,15,15,8,8,9,0,0,0,0,0,0,0,0,0
    .byte 0,0,0,0,9,9,0,0,0,0,0,9,8,15,8,15
    .byte 8,15,8,9,0,0,0,0,0,0,0,0,0,0,0,0
    .byte 0,0,8,15,15,15,15,15,9,0,0,0,0,9,8,15
    .byte 8,9,0,0,0,0,9,8,15,15,15,15,8,8,0,0
    .byte 0,8,9,9,0,0,9,15,15,8,2,0,0,0,8,15
    .byte 8,0,0,0,9,8,15,15,15,9,0,9,9,8,8,0
    .byte 9,0,0,15,9,9,0,9,0,0,0,9,0,0,8,8
    .byte 8,2,0,9,0,9,0,9,9,0,8,15,15,0,2,9
    .byte 8,8,9,15,15,8,0,9,8,15,15,0,9,0,8,15
    .byte 15,8,0,9,15,15,9,8,0,9,8,15,15,8,8,8
    .byte 15,8,15,15,15,15,15,15,15,15,15,15,9,2,15,15
    .byte 15,8,9,9,15,15,15,15,15,15,15,15,15,15,15,8
    .byte 8,8,8,15,15,15,8,8,8,2,9,9,9,9,9,15
    .byte 9,9,9,9,0,2,8,8,8,15,15,15,15,15,8,2
    .byte 0,0,9,9,9,9,9,9,9,0,15,0,0,9,0,0
    .byte 0,0,9,0,0,9,0,0,9,9,15,9,9,0,0,0
    .byte 0,0,0,15,9,0,0,15,0,0,15,0,0,0,15,9
    .byte 0,0,15,0,0,15,0,0,0,0,9,0,9,0,0,0
    .byte 0,0,0,15,0,15,9,10,0,0,15,9,0,0,15,0
    .byte 15,9,10,0,0,15,9,0,0,9,15,0,15,9,0,0
    .byte 0,0,0,15,9,0,15,10,2,0,10,2,0,0,15,9
    .byte 0,15,10,2,0,15,15,0,0,15,2,0,0,15,2,0
    .byte 0,0,0,10,2,0,2,10,2,0,10,10,0,0,10,2
    .byte 0,2,10,2,0,2,10,0,0,10,2,9,2,2,10,2
    .byte 0,0,0,10,10,0,0,10,10,0,10,10,10,2,10,10
    .byte 0,0,10,10,0,10,10,2,10,10,0,0,0,2,10,2
    .byte 0,0,2,10,10,0,0,2,2,0,0,2,0,10,10,2
    .byte 0,0,2,0,2,10,10,2,2,2,0,0,0,2,10,10
    .byte 0,0,2,10,2,0,0,0,0,0,0,0,0,10,10,2
    .byte 0,0,0,0,10,10,10,0,0,0,0,0,0,2,10,2
   PROCESSOR 6502
   ORG $0600
;
; testing byterun compression
 
start:
  lda #<logo
  sta $0
  lda #>logo
  sta $1
  lda #$00
  sta $2
  lda #$02
  sta $3

decrunchLoop:
  lda $3
  cmp #$6
  bne moreWork 
  rts
moreWork:
  ldy #0
  lda ($0),y
  cmp #$ff
  bne notCrunched
  iny
  lda ($0),y ; repeat #
  sta $4
  iny
  lda ($0),y ; color
  ldy $4
drawLoop:
  ldx #0
  sta ($2,x)
  jsr nextPixel
  dey
  bne drawLoop
  jsr getNextByte
  jsr getNextByte
  jmp decrunchLoop
notCrunched:
  ldx #0
  sta ($2,x)
  jsr nextPixel
  jsr getNextByte
  jmp decrunchLoop

getNextByte:
  inc $0
  lda $0
  cmp #$00
  bne notHi
  inc $1
notHi:
  rts

nextPixel:
  inc $2
  ldx $2
  cpx #$00
  bne notNextLine
  inc $3
notNextLine:
  rts


logo:
 .byte $ff,43,1,$f,$f,$f,$c,$f,$f,$f,$ff,24,1,$c,$f,$c,0
 .byte $c,$f,$c,$ff,24,1,0,$f,$c,0,$c,$f,$c,$ff,24,1
 .byte $c,$f,$c,0,$c,$f,$c,$ff,24,1,0,$f,$c,0,$c,$f,$c
 .byte $ff,24,1,$c,$f,0,0,$c,$f,$c,$ff,24,1,0,$f,$c,0
 .byte $c,$f,$c,$ff,24,1,0,$f,$c,0,$c,$f,0,$ff,24,1
 .byte 0,$f,$c,0,$c,$f,0,$ff,23,1,$f,0,$f,$c,0,$c,$f,0,$f
 .byte $ff,22,1,$c,0,1,$c,0,$c,$f,0,$c,$ff,21,1
 .byte $f,0,0,1,0,0,$c,1,0,0,$ff,21,1,$c,0,$c,1,$c,0
 .byte $c,1,$c,0,$c,$ff,19,1,$f,0,0,$f,1,$c,0
 .byte $c,1,$f,0,0,$f,$ff,17,1,$f,0,0,0,1,1,$c,0
 .byte $c,1,1,0,0,0,$ff,16,1,$f,0,0,0,$f,1,1,0,0
 .byte $c,1,1,$f,0,0,0,$f,$ff,13,1
 .byte $c,0,0,0,$c,1,1,1,$c,0,$c,1,1,1,$c,0,0,0,$c
 .byte $ff,10,1,$c,0,0,0,0,$c,1,1,1,1,0,0
 .byte $c,1,1,1,1,0,0,0,0,0,$c,$ff,8,1
 .byte 0,0,0,0,$c,1,1,1,1,1,0,0
 .byte $c,1,1,1,1,1,$c,0,0,0,0,1,1,1,1,1
 .byte 1,1,1,1,0,0,$c,1,1,1,1,1,1,1,$c,0
 .byte $c,1,1,1,1,1,1,$f,$c,0,0,$ff,18,1,$f
 .byte $ff,53,1,0,$f,1,0,0,0,0,0,$f,1,$c
 .byte $c,1,1,1,$c,0,0,0,1,1,0,$f,$f,1,1,1
 .byte 1,1,1,1,$c,0,0,1,1,1,0,$f,1,1,$f,0
 .byte 0,$f,1,1,0,$f,1,$c,$c,1,0,$f,1,1,1,1
 .byte 1,1,1,1,0,$f,0,$f,1,1,0,$f,1,1,$f,$c
 .byte $c,$c,1,1,0,1,1,$f,0,1,0,$f,1,1,1,1
 .byte 1,1,1,1,0,1,$c,$f,1,1,$c,$f,1,1,0,$f
 .byte $f,0,1,1,0,$f,$f,0,$f,1,0,$f,1,1,1,1
 .byte 1,1,1,$c,0,$c,0,0,1,1,0,$f,1,1,0,$c
 .byte $c,0,$f,1,0,$f,0,$f,1,1,0,$f,1,1,1,1
 .byte 1,1,1,0,$c,$f,$f,0,$f,1,$c,$f,1,$c,$c,$f
 .byte $f,$c,$c,1,0,1,$f,$c,1,1,0,$f,1,1,1,1
 .byte 1,1,$f,0,1,1,1,$c,$c,1,0,$f,1,0,$f,1
 .byte 1,$f,0,1,0,$f,1,0,$f,1,0,$f,$ff,16,1
 .byte $f,$ff,5,1,$f,1,1,1,$f,$ff,38,1


   PROCESSOR 6502
   ORG $0600
   
loop: lda $fe       ; A=rnd
      sta $00       ; ZP(0)=A
      lda $fe
      and #$3       ; A=A&3
      clc           ; Clear carry
      adc #$2       ; A+=2
      sta $01       ; ZP(1)=A
      lda $fe       ; A=rnd
      ldy #$0       ; Y=0
      sta ($00),y   ; ZP(0),ZP(1)=y
      jmp loop
   PROCESSOR 6502
   ORG $0600
; Sierpinski-like triangles
; Submitted by Anonymous

start:
  ldx #0
  lda #$00
  sta $0
  lda #$02
  sta $1
write:
  jsr point
  sta ($0,x)
  inc $0
  beq highbyte
  jmp write

highbyte:
  inc $1
  ldy $1
  cpy #$06
  bne write
  rts

point:
  lda $0
  and #$1f
  sta $2 ;x
  lda $0
  lsr
  lsr
  lsr
  lsr
  lsr
  sta $3
  lda $1
  sec
  sbc #2
  asl
  asl
  asl
  ora $3
  and $2
  beq okay
  lda #2
  rts
okay:
  lda #13
  rts
   PROCESSOR 6502
   ORG $0600
; software sprites
; by PJP

loop:
 ldx $90
 inx
 stx $90

 lda #4          ; *** NUMBER OF SPRITES
 sta $3
 lda #0
 sta $4

multiple:
 lda $90
 clc
 adc $4
 tax

 lda sinus,x
 ldy cosinus,x
 asl
 tax
 lda ypos,x
 sta $00
 inx
 lda ypos,x
 sta $01
 ldx #0
 lda #5    ; **** HEIGHT OF EACH SPRITE
 sta $2
draw:
 lda image,x
 sta ($0),y
 inx
 iny
 lda image,x
 sta ($0),y
 inx
 iny
 lda image,x
 sta ($0),y
 inx
 iny
 lda image,x
 sta ($0),y
 inx
 iny
 lda image,x
 sta ($0),y


 tya
 clc
 adc #28
 tay
 inx
 dec $2
 bne draw

 lda $4 
 clc
 adc #18        ; *** DISTANCE BETWEEN SPRITES (FROM TABLE)
 sta $4

 dec $3
 bne multiple

 jmp loop

; SINUS (AND COSINUS) 

sinus:
 .byte $0e, $0e, $0e, $0f, $0f, $0f, $10, $10, $10, $11
 .byte $11, $11, $12, $12, $12, $13, $13, $13, $14, $14
 .byte $14, $14, $15, $15, $15, $16, $16, $16, $16, $17
 .byte $17, $17, $17, $18, $18, $18, $18, $19, $19, $19
 .byte $19, $19, $1a, $1a, $1a, $1a, $1a, $1a, $1a, $1b
 .byte $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b
 .byte $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b
cosinus:
 .byte $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b
 .byte $1a, $1a, $1a, $1a, $1a, $1a, $19, $19, $19, $19
 .byte $19, $18, $18, $18, $18, $18, $17, $17, $17, $17
 .byte $16, $16, $16, $15, $15, $15, $15, $14, $14, $14
 .byte $13, $13, $13, $12, $12, $12, $11, $11, $11, $10
 .byte $10, $10, $0f, $0f, $0f, $0e, $0e, $0e, $0d, $0d
 .byte $0d, $0c, $0c, $0c, $0b, $0b, $0b, $0a, $0a, $0a
 .byte $09, $09, $09, $08, $08, $08, $07, $07, $07, $06
 .byte $06, $06, $06, $05, $05, $05, $04, $04, $04, $04
 .byte $03, $03, $03, $03, $03, $02, $02, $02, $02, $02
 .byte $01, $01, $01, $01, $01, $01, $00, $00, $00, $00
 .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
 .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
 .byte $00, $00, $00, $00, $00, $00, $00, $01, $01, $01
 .byte $01, $01, $01, $01, $02, $02, $02, $02, $02, $03
 .byte $03, $03, $03, $04, $04, $04, $04, $05, $05, $05
 .byte $05, $06, $06, $06, $07, $07, $07, $07, $08, $08
 .byte $08, $09, $09, $09, $0a, $0a, $0a, $0b, $0b, $0b
 .byte $0c, $0c, $0c, $0d, $0d

 .byte $0e, $0e, $0e, $0f, $0f, $0f, $10, $10, $10, $11
 .byte $11, $11, $12, $12, $12, $13, $13, $13, $14, $14
 .byte $14, $14, $15, $15, $15, $16, $16, $16, $16, $17
 .byte $17, $17, $17, $18, $18, $18, $18, $19, $19, $19
 .byte $19, $19, $1a, $1a, $1a, $1a, $1a, $1a, $1a, $1b
 .byte $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b
 .byte $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b
 .byte $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b, $1b
 .byte $1a, $1a, $1a, $1a, $1a, $1a, $19, $19, $19, $19

; 5x5 BYTES

image:
 .byte $0,$0,$0,$0,$0
 .byte $0,$c,$c,$c,$0
 .byte $0,$c,$1,$c,$0
 .byte $0,$c,$c,$c,$0
 .byte $0,$0,$0,$0,$0

; YPOS LOOKUP TABLE

ypos:
 .byte $00,$02,$20,$02,$40,$02,$60,$02
 .byte $80,$02,$a0,$02,$c0,$02,$e0,$02
 .byte $00,$03,$20,$03,$40,$03,$60,$03
 .byte $80,$03,$a0,$03,$c0,$03,$e0,$03
 .byte $00,$04,$20,$04,$40,$04,$60,$04
 .byte $80,$04,$a0,$04,$c0,$04,$e0,$04
 .byte $00,$05,$20,$05,$40,$05,$60,$05
 .byte $80,$05,$a0,$05,$c0,$05,$e0,$05

   PROCESSOR 6502
   ORG $0600
   
; Brick Out by Blake Ramsdell <blaker@gmail.com> http://www.blakeramsdell.com

; A poor attempt at brick out with no player involved. Maybe someday I'll
; let you play it, or you can view this as an exercise for the reader to put
; in a paddle that is user-controlled.

; I guess this is Copyright (C) 2007 Blake Ramsdell, and you have a license to
; do whatever you want with it, just tell me what you did and give me a
; mention. If you want to sell it, and you make a billion dollars, then good
; for you. You might at least throw a party and invite me.

; The gist of it is pretty simple -- you have a ball, and the ball has an X
; and a Y velocity. When it hits something, it bounces off of it. If the thing
; that it hits is not a wall, then it erases it. Pretty dead-simple behavior.

; I don't like the vertical movement -- there's a shortcut in here somewhere
; to make it less computationally expensive I think. Right now it just does a
; two byte add and subtract of $20.

; The ball motion is also a bit weird looking. I don't know if this is an
; artifact of the simulation environment combined with a normal tearing
; artifact related to refresh or what.

; Blake Ramsdell, May 2007

init:
 lda #$fe
 sta $2         ; X velocity (0 = fast, ff = slow)
                ; (low bit is direction, 0 = down or right, 1 = up or left)
 lda #$ee
 sta $3         ; Y velocity

drawbox:
 lda #0         ; Use $0-$1 as a screen address for drawing the field
 sta $0
 lda #2
 sta $1

 ldx #$20       ; Loop $20 times
boxloop:
 lda #2         ; Line color (red)
 sta $1ff,x     ; Top line
 sta $5df,x     ; Bottom line
 ldy #0
 sta ($0),y     ; Left line
 ldy #$1f
 sta ($0),y     ; Right line

 cpx #$1        ; If we're just before the bottom line...
 beq noblocks   ; Don't draw any blocks there


 lda #3         ; First block for this row, Cyan in color
 ldy #$17       ; It's at X position $17
 sta ($0),y     ; Draw it

 lda #4         ; Second block for this row, Purple in color
 iny            ; It's at the next X position
 sta ($0),y     ; Draw it

 lda #5         ; Third block for this row, Green in color
 iny            ; It's at the next X position
 sta ($0),y     ; Draw it

 lda #6         ; Fourth block for this row, Blue in color
 iny            ; It's at the next X position
 sta ($0),y     ; Draw it


noblocks:
 clc            ; Get ready to increment the row, clear the carry for add
 lda $0         ; Get the low byte
 adc #$20       ; Add $20 to it for the next row
 sta $0         ; Put it back
 lda $1         ; Get the high byte
 adc #0         ; Factor in the carry
 sta $1         ; Put it back

 dex            ; Decrement the loop counter
 bne boxloop    ; Do it again unless it's zero

 ldx $2         ; Load the X velocity
 ldy $3         ; Load the Y velocity

 lda #$44       ; Pick a start point
 sta $0         ; Ball position low
 lda #$02
 sta $1         ; Ball position high

drawball:
 txa            ; Preserve X
 pha
 lda #1         ; Ball color (white)
 ldx #0         ; Clear X for indirect addressing for writing to screen
 sta ($0,x)     ; Draw the ball
 pla            ; Restore X
 tax

decloop:
 dex            ; Decrement the X velocity
 beq updatexpos ; If it's zero, time to adjust X
 dey            ; Decrement the Y velocity
 bne decloop    ; If it's not zero, loop, otherwise fall through to adjust Y

updateypos:
 txa            ; Preserve X
 pha
 jsr clearball  ; Put background over the current ball position
updateyposnoclear:
 lda $3         ; Get the Y velocity
 and #1         ; See if it's down
 bne moveup     ; If not, then it's up, otherwise fall through to down

movedown:
 clc            ; Prepare for moving to the next Y line and doing the add
 lda $0         ; Low byte of the current ball position
 adc #$20       ; Next row
 sta $0         ; Put it back
 bcc ycollision ; If no carry, go on to check for collision
 inc $1         ; Had a carry, fix the high byte of the address
 bne ycollision ; Z flag is always clear ($1 will never be zero)

moveup:
 sec            ; Prepare for moving to the previous Y line and subtracting
 lda $0         ; Low byte of the current ball position
 sbc #$20       ; Previous row
 sta $0         ; Put it back
 lda $1         ; High byte
 sbc #$0        ; Factor out the carry
 sta $1         ; Put it back

ycollision:
 ldx #0         ; Prepare for indirect read
 lda ($0,x)     ; Get the current pixel at the new ball position
 bne ycollided  ; If it's not zero (the background color) then we hit
 ldy $3         ; Otherwise, load up the current Y velocity
 pla            ; Restore the X velocity
 tax
 jmp drawball   ; Back to the top

ycollided:
 cmp #$2        ; Border color?
 beq ycollided2 ; If so, then we just bounce, don't eat a brick

                ; Erase brick
 lda #0         ; Background color (black)
 sta ($0,x)     ; Erase it

ycollided2:
 lda #1         ; Get ready to change direction
 eor $3         ; Flip the low bit on the Y velocity (change direction)
 sta $3         ; Put it back
 jmp updateyposnoclear  ; Go back to make sure we didn't hit anything else

updatexpos:
 jsr clearball  ; Put background over the current ball position
updatexposnoclear:
 lda $2         ; Get the current X velocity
 and #1         ; See if it's right by testing the low bit
 bne moveleft   ; If not, move left

moveright:
 inc $0         ; Move right
 bne xcollision ; Z flag is always clear

moveleft:
 dec $0         ; Move left

xcollision:
 ldx #0         ; Prepare for indirect read
 lda ($0,x)     ; Get the current pixel at the new ball position
 bne xcollided  ; If it's not zero (the background color) then we hit
 ldx $2         ; Otherwise, load up the current X velocity
 jmp drawball   ; Back to the top

xcollided:
 cmp #$2        ; Border color?
 beq xcollided2 ; If so, then we just bounce, don't eat a brick

                ; Erase brick
 lda #0         ; Background color (black)
 sta ($0,x)     ; Erase it

xcollided2:
 lda #1         ; Get ready to change direction
 eor $2         ; Flip the low bit on the X velocity (change direction)
 sta $2         ; Put it back
 jmp updatexposnoclear  ; Go back to make sure we didn't hit anything else

clearball:
 lda #0         ; Background color (black)
 tax            ; Clear X for indirect
 sta ($0,x)     ; Black out the ball
 rts            ; Return to caller

   PROCESSOR 6502
   ORG $0600
   
; 6502 assembler Sierpinsky Triangle ver.2
; by Magnus Wedmark 2007-05-02
; This program is especially written for
; the 6502asm.com competition and 
; uses the 32*32 pixel display used in that
; virtual platform. The sierpinsky 
; fractal is one of the simplest to
; implement. Here is a walk-through:
; 1) Specify 3 points that form a triangle
; 2) Choose one of them as a starting point
; 3) Choose one of them as targetpoint randomly
; 4) Set the new current position half-way 
;    between the current point and the target 
;    point.
; 5) Goto 3
	
	LDX #0
	LDY #0
new_rnd:
	LDA $FE       ; random 0-255
	AND #3        ; only 0-3 left
	CMP #3
	BNE good_rnd
	JMP new_rnd
good_rnd:     
; random = 0-2
	PHA
; transform X and Y values according to: 
; X=X/2+(P*8) and Y=Y/2+(P*16)
	ASL
	ASL
	ASL
	STA $F3 ; P*8
	PLA
	AND #1
	ASL
	ASL
	ASL
	ASL
	STA $F4 ; (P AND 1)*16
	TXA
	LSR
	ADC $F3
	TAX
	TYA
	LSR
	ADC $F4
	TAY
	JSR set_point	; use and restore regs
	JMP new_rnd

set_point: ; uses both X,Y,A and restores them
	PHA ; backup all reg-value (X,Y,A)
	TXA
	PHA
	TYA
	PHA 
	PHA 
	PHA ; triple Y push, two for int. use
	STX $F2  ; transfer X to Y using $F2
	LDY $F2
	LDA #0
	STA $F0
	LDA #$2
	STA $F1 ; set base vector to $200
	LDA #0
	PLA  ; transfer the pushed Y-coord to A
	AND #$07 ; the value %0000'0111
	ASL
	ASL
	ASL
	ASL
	ASL
	CLC
	ADC $F0
	STA $F0
	BCC no_carry
	INC $F1
no_carry:
	CLC
	PLA ; transfer the pushed Y-coord to A
	AND #$18
	LSR
	LSR
	LSR
	ADC $F1
	STA $F1		

	CLC
	TYA
	ADC $F0
	ADC $F1

	LDA #1 ;1 = white for trouble-shooting
   	JSR set_toning_point ; use for shading
	STA ($F0),Y  ; set pixel
	PLA  ; restore all reg-value (X,Y,A)
	TAY
	PLA
	TAX
	PLA
	RTS

; sub routine to shade the current pixel ($F0),Y
; lighter on a scale: $0, $B, $C, $F, $1 
; Black, DarkGrey, Grey, LightGrey, White
set_toning_point:
        LDA ($F0),Y
        CMP #$00
        BNE not_black
        LDA #$0B
        RTS
not_black:
        CMP #$0B
        BNE not_dgrey
        LDA #$0C
        RTS
not_dgrey:
        CMP #$0C
        BNE not_grey
        LDA #$0F
        RTS
not_grey:
        CMP #$0F
        BNE not_lgrey
        LDA #$01
        RTS
not_lgrey:
; white stays white
        RTS

   PROCESSOR 6502
   ORG $0600
; 2d starfield
; Submitted by Anonymous

i:
  ldx #$7
g:
  lda $fe
  and #3
  adc #1
  sta $0,x
  lda $fe
  and #$1f
  sta $20,x
  dex
  bpl g
f:
  lda #$00
  sta $80
  lda #$02
  sta $81
  ldx #$7
l:
  lda $20,x
  pha
  clc
  sbc $00,x
  and #$1f
  sta $20,x
  lda $20,x
  tay
  lda #1
  sta ($80),y
  pla
  tay
  lda #0
  sta ($80),y
  lda $80
  clc
  adc #$80
  bne n
  inc $81
n:
  sta $80
  dex
  bpl l
  jmp f

   PROCESSOR 6502
   ORG $0600
;
; moves a dot back and forth
;

start:
  lda #$f
  sta $0               ; Xpos = 15
  lda #$4
  sta $1               ; Ypos = $02(0f) (top line)
  lda #$01
  sta $2               ; direction (0=left, 1=right)

mainloop:
  lda $00              ; load Xpos
  sta $03              ; save it..
  lda $01              ; load Ypos
  sta $04              ; save it..

  lda $02              ; check direction
  cmp #$00             ; left?
  bne notLeft
  inc $0               ; increment X
  jmp checkBounce
notLeft:
  dec $0               ; decrement X

checkBounce:
  ldx $02              ; regX = direction
  lda $0               ; load xpos
  cmp #$1f             ; at-most right?
  bne notBounceLeft
  ldx #$1              ; go left
  jmp draw             ; draw dot
notBounceLeft:
  cmp #$0              ; at-most right?
  bne draw
  ldx #$0              ; go right
draw:
  stx $02              ; update direction

  lda #$1              ; A=1 white color
  ldx #$0
  sta ($0,x)           ; draw dot

  lda #$0              ; A=0 black color
  ldx #$0
  sta ($3,x)           ; erase previous dot

  jmp mainloop         ; continue forever
     PROCESSOR 6502
   ORG $0600

; I'm alive
; by PJP

start:
 lda #15
 sta $0 ;xpos
 sta $1 ;ypos

loop:
 lda $fe
 and #3
 cmp #0
 beq go_left
 cmp #1
 beq go_right
 cmp #2
 beq go_down
 dec $1
draw:
 lda $1
 and #$1f
 asl
 tax
 lda ypos,x
 sta $2
 inx
 lda ypos,x
 sta $3
 lda $0
 and #$1f
 tay
 lda ($2),y
 tax
 inx
 txa
 sta ($2),y
 jmp loop
go_down:
 inc $1
 jmp draw
go_left:
 dec $0
 jmp draw
go_right:
 inc $0
 jmp draw

ypos:
 .byte $00,$02,$20,$02,$40,$02,$60,$02
 .byte $80,$02,$a0,$02,$c0,$02,$e0,$02
 .byte $00,$03,$20,$03,$40,$03,$60,$03
 .byte $80,$03,$a0,$03,$c0,$03,$e0,$03
 .byte $00,$04,$20,$04,$40,$04,$60,$04
 .byte $80,$04,$a0,$04,$c0,$04,$e0,$04
 .byte $00,$05,$20,$05,$40,$05,$60,$05
 .byte $80,$05,$a0,$05,$c0,$05,$e0,$05


   PROCESSOR 6502
   ORG $0600
; "spacer", move a space ship through an
; endless tunnel.  You die once you hit
; the walls.
;
; Controls:
;
;   W - move up
;   X - move down
;   Any other key will stop the ship
;
; Ps: this game runs awfully slow =)
;

start:
  jsr init

loop:
  jsr drawShip
  jsr drawMap
  jsr genMap
  jsr readKeys
  jmp loop

;--

drawShip:
  lda $60
  asl
  tay

  lda ypos,y
  sta $00
  iny
  lda ypos,y
  sta $01

  ldy #42
  lda ($00),y
  cmp #0
  beq noCrash
  cmp #5
  bne crashed
noCrash:
  lda #5
  sta ($00),y

  lda $60
  cmp $61
  beq ret

  lda $61
  asl
  tay
  lda ypos,y
  sta $00
  iny
  lda ypos,y
  sta $01
  lda #0
  ldy #42
  sta ($00),y

  lda $60
  sta $61
ret:
  rts

;--

crashed:
  lda $fe
  sta ($00),y
  jmp crashed

;--

readKeys:
  lda $ff
  cmp #119
  bne notUp
  dec $60
  rts
notUp:
  cmp #120
  bne noMove
  inc $60
noMove:
  rts

;--

init:
  ldx #0
drawLogo:
  lda bottomLogo,x
  sta $500,x
  inx
  cpx #0
  bne drawLogo

  lda #10
  sta $60
  sta $61

  ldx #0
  lda #$c
c:sta $200,x
  sta $400,x
  dex
  cpx #0
  bne c

  lda #16
  sta $80  ; origin
  ldx #15
set:
  sta $81,x  ; target
  dex
  bpl set
  rts

;--

drawMap:
  lda #0
  sta $78
  lda #32
  sta $79
  lda #192
  sta $7a
  lda #224
  sta $7b

  ldx #15
drawLoop:
  lda $81,x
  sta $82,x
  tay
  lda ypos,y
  sta $00
  iny
  lda ypos,y
  sta $01

  lda #$c
  ldy $78
  sta ($00),y
  iny
  sta ($00),y

  ldy $7b
  sta ($00),y
  iny
  sta ($00),y

  ldy $79
  lda #0
  sta ($00),y
  iny
  sta ($00),y

  ldy $7a
  sta ($00),y
  iny
  sta ($00),y

  inc $78
  inc $79
  inc $7a
  inc $7b
  inc $78
  inc $79
  inc $7a
  inc $7b
  dex
  bpl drawLoop
  rts

;---

genMap:
  lda $80
  cmp $81
  beq done
  lda $80
  clc
  sbc $81
  bpl plus
  bmi minus
done:
  lda $fe
  and #$f
  asl
  sta $80
  rts
minus:
  dec $81
  dec $81
  rts
plus:
  inc $81
  inc $81
  rts

ypos:
  .byte $00,$02,$20,$02,$40,$02,$60,$02
  .byte $80,$02,$a0,$02,$c0,$02,$e0,$02
  .byte $00,$03,$20,$03,$40,$03,$60,$03
  .byte $80,$03,$a0,$03,$c0,$03,$e0,$03
  .byte $00,$04,$20,$04,$40,$04,$60,$04
  .byte $80,$04,$a0,$04,$c0,$04,$e0,$04
  .byte $00,$05,$20,$05,$40,$05,$60,$05
  .byte $80,$05,$a0,$05,$c0,$05,$e0,$05

bottomLogo:
  .byte $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
  .byte $0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0,$0
  .byte $0,$0,$0,$0,$0,$0,$1,$1,$1,$6,$1,$1,$1,$0
  .byte $0,$6,$1,$1,$6,$0,$0,$1,$1,$1,$6,$0,$1,$1
  .byte $1,$0,$1,$1,$1,$6,$0,$0,$6,$1,$6,$0,$6,$0
  .byte $1,$0,$6,$1,$6,$1,$6,$0,$1,$0,$1,$0,$6,$0
  .byte $6,$1,$6,$0,$6,$0,$1,$0,$6,$1,$6,$0,$0,$6
  .byte $1,$1,$6,$6,$1,$1,$1,$0,$6,$1,$0,$0,$1,$0
  .byte $1,$6,$0,$6,$6,$1,$1,$1,$0,$6,$1,$0,$6,$1
  .byte $0,$6,$6,$6,$6,$6,$1,$6,$1,$1,$6,$6,$6,$1
  .byte $1,$1,$1,$6,$1,$6,$6,$6,$6,$1,$6,$6,$6,$6
  .byte $1,$1,$1,$6,$6,$6,$6,$1,$1,$1,$1,$e,$1,$1
  .byte $e,$6,$6,$1,$1,$6,$1,$6,$1,$1,$1,$1,$e,$1
  .byte $1,$1,$1,$6,$1,$1,$6,$1,$6,$6,$6,$1,$1,$1
  .byte $6,$e,$1,$1,$6,$e,$6,$1,$1,$e,$1,$e,$6,$1
  .byte $1,$1,$6,$e,$1,$1,$1,$e,$1,$1,$6,$1,$6,$e
  .byte $e,$e,$6,$e,$e,$6,$e,$e,$6,$e,$e,$6,$e,$e
  .byte $6,$e,$e,$6,$e,$e,$6,$e,$e,$6,$e,$e,$6,$e
  .byte $e,$6,$e,$e

   PROCESSOR 6502
   ORG $0600
;
;  draw image
;

start:
  lda #<logo
  sta $0
  lda #>logo
  sta $1

  lda #$00
  sta $2
  lda #$02
  sta $3

  ldx #$0
l:
  lda ($0,x)
  sta ($2,x)

  inc $00
  lda $00
  cmp #$00
  bne notReset1
  inc $01
notReset1:

  inc $02
  lda $02 
  cmp #$00
  bne notReset2
  lda $03
  cmp #$05
  beq done
  inc $03
notReset2:

  jmp l
done:
  rts

logo:
 .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,6,6,6
 .byte 6,6,6,6,1,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,1,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,6,6,6,6,6,6,6,6,6,6,6,6,1
 .byte 1,1,1,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,6,6,6,6,6,6,6,6,6,6,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6
 .byte 1,1,6,6,6,6,6,6,6,6,6,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,1
 .byte 1,1,6,6,6,6,6,6,6,6,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,6,6,1,1
 .byte 1,1,6,6,6,6,6,6,6,6,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,6,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,1,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,1,1,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,1,1,1,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,1,1,1,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,2,1,1,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1
 .byte 1,6,6,6,6,6,6,6,6,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,2,2,2,1,1,1
 .byte 1,1,6,6,6,6,6,6,6,6,1,1,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,2,2,2,2,1,1
 .byte 1,1,6,6,6,6,6,6,6,6,6,1,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,1
 .byte 1,1,1,6,6,6,6,6,6,6,6,6,1,1,1,1
 .byte 1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2
 .byte 1,1,1,6,6,6,6,6,6,6,6,6,6,1,1,1
 .byte 1,1,1,1,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,6,6,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,6,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,6,6,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,6,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,6,6,6,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,1,1,1,6,6,6,6
 .byte 6,6,6,6,6,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
 .byte 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
   PROCESSOR 6502

; adventure.asm
;
; A simple adventure-like game for the 6502asm.com site
;
; RRRRR    EEEEEE     AA     DDDDD        MM      MMM  EEEEEE
; RR  RR   EE       AA  AA   DD  DD       MMM    MMMM  EE
; RRRRR    EEEEEE   AAAAAA   DD   DD      MM MM MM MM  EEEEEE
; RR  RR   EE      AA    AA  DD  DD       MM  MM   MM  EE
; RR   RR  EEEEEE  AA    AA  DDDDD        MM  MM   MM  EEEEEE
;
; Thank you for trying my game! You are Good Guy, and you are on a
; quest to defeat Bad Guy, the only other guy in this area of The
; World.
;
; You start in the forest. Somewhere within the forest are a pair of
; flippers, which will allow you to swim in the river. Somewhere along
; the banks of the river there is a key to the White Castle. Within the
; White Castle are a protective crown and a deadly weapon (it looks like
; a red star thingy). These two items are needed to defeat Evil Guy.
;
; Evil Guy lives in the Black Castle, which you can get to through the
; desert. Conveniantly enough, the key to the Black Castle is somewhere
; in the desert.
;
; Find Evil Guy in the Black Castle while wearing the crown and weapon
; and you win! If you lack either the crown or weapon, the screen will
; flash only red, and you will loose! 
;
; Copyright (c) 2010 Norman B. Lancaster
;
;  Released under the GNU General Public License version 3 or later.
;  See http://gnu.org/licenses/gpl.html
;
;

    org 128
player_map_x: .byte 00
player_map_y: .byte 00
player_screen_x: .byte 00
player_screen_y: .byte 00
player_sprite: .byte 00
screen_item_x: .byte 00
screen_item_y: .byte 00
screen_item_idx: .byte 00
item_flags: .byte 00

random: equ $FE
keypress: equ $FF

 org 512
frame_buffer:

 org $0600
  jmp		start

; screen_item_x:		  .byte $00
;screen_item_y:		  .byte $00
; screen_item_idx:	  .byte $00

; Screen RAM, 64 Bytes
screen_ram:
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
    .byte $0f,$03,$0f,$05,$0f,$0f,$0f,$0f
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f
    .byte $0f,$0f,$0f,$0f,$0f,$0f,$0f,$0f

; Item RAM, 64 Bytes
; Map X, Screen X, Map Y, Screen Y, Item Number, Fill x3
item_ram:
    .byte $00,$05,$00,$05,$00,$00,$00,$00 ; Flippers
    .byte $01,$05,$00,$05,$01,$00,$00,$00 ; White Key
    .byte $0d,$05,$0d,$05,$02,$00,$00,$00 ; Black Key
    .byte $0d,$05,$0e,$05,$03,$00,$00,$00 ; Crown
    .byte $0d,$04,$0c,$05,$04,$00,$00,$00 ; Death Star
    .byte $08,$03,$0d,$03,$05,$00,$00,$00 ; Evil Guy (DO NOT MAKE TAKEABLE!)
    .byte $ff,$ff,$ff,$ff,$06,$00,$00,$00 ; Not Used
    .byte $ff,$ff,$ff,$ff,$07,$00,$00,$00 ; Not Used

start:
	; Init item patch table pointers
	ldx		#0
	lda		#<screen_data
	sta		item_patch_table_lo,x
	lda		#>screen_data
	sta		item_patch_table_hi,x
	inx
	lda		#<sprite_data
	sta		item_patch_table_lo,x
	lda		#>sprite_data
	sta		item_patch_table_hi,x
	inx
	lda		#<tile_flags
	sta		item_patch_table_lo,x
	lda		#>tile_flags
	sta		item_patch_table_hi,x
	inx
	lda		#<item_flags
	sta		item_patch_table_lo,x
	lda		#>item_flags
	sta		item_patch_table_hi,x
	
	; Init player position, etc
	lda		#$00
	sta		player_map_x
	lda		#$00
	sta		player_map_y
	lda		#0
	sta		player_sprite
	lda		#4
	sta		player_screen_x
	sta		player_screen_y
	sta		keypress
	jsr		spawn_items
	
	; Initial map rendering
	jsr		update_map_screen
	jsr		blit_player

	; Main game loop
main_loop:
		; Debug, load location info into registers
		lda		player_map_x
		asl
		asl
		asl
		asl
		ora		player_screen_x
		tax
		lda		player_map_y
		asl
		asl
		asl
		asl
		ora		player_screen_y
		tay
		
		; Wait for input
input_loop:
			lda		keypress
			beq		input_loop
			ldx		#0
			stx		keypress
		
		; Act on input (key code in A)
		cmp		#97					; Move left
		bne		test_input_1
			jmp		input_do_move_left
test_input_1:
		cmp		#104				; Move left
		bne		test_input_2
			jmp		input_do_move_left
test_input_2:
		cmp		#100				; Move right
		bne		test_input_3
			jmp		input_do_move_right
test_input_3:
		cmp		#108				; Move right
		bne		test_input_4
			jmp		input_do_move_right
test_input_4:
		cmp		#119				; Move up
		bne		test_input_5
			jmp		input_do_move_up
test_input_5:
		cmp		#107				; Move up
		bne		test_input_6
			jmp		input_do_move_up
test_input_6:
		cmp		#115				; Move down
		bne		test_input_7
			jmp		input_do_move_down
test_input_7:
		cmp		#106				; Move down
		bne		test_input_8
			jmp		input_do_move_down
test_input_8:
		jmp		input_loop
		
; Input handlers
input_do_move_left:
  lda		#2
  ldx		player_screen_x
  ldy		player_screen_y
  dex
  jsr		move_player
  jmp		main_loop
input_do_move_right:
	lda		#1
	ldx		player_screen_x
	ldy		player_screen_y
	inx
	jsr		move_player
	jmp		main_loop
input_do_move_up:
	lda		#3
	ldx		player_screen_x
	ldy		player_screen_y
	dey
	jsr		move_player
	jmp		main_loop
input_do_move_down:
	lda		#0
	ldx		player_screen_x
	ldy		player_screen_y
	iny
	jsr		move_player
	jmp		main_loop

end:
	jmp		end

;
;
; palette_rotate_effect
;
; Rotate all colors in the framebuffer
;
; Uses
;	$2 - $3	Framebuffer pointer
;	$4		Itterations counter
;	$5		Step
;	$6		Itterations
;
; Inputs
;	A		Palette rotation step
;	X		Number of itterations
palette_rotate_effect_max_fb_page:		  .byte $00
palette_rotate_effect:
	sta		$5
	stx		$6
	; Loop through itterations
	lda		#0
	sta		$4
palette_rotate_effect_itter_loop:
		lda		#<frame_buffer
		sta		$2
		lda		#>frame_buffer
		sta		$3
		; Loop through pixels
		ldx		#0
palette_rotate_effect_pixel_page_loop:
			ldy		#0
palette_rotate_effect_pixel_loop:
				lda		($2),y
				clc
				adc		$5
				sta		($2),y
				iny
				bne		palette_rotate_effect_pixel_loop
			; Page step
			inc		$3
			inx
			cpx		#4
			bne		palette_rotate_effect_pixel_page_loop
		; Itteration step
		inc		$4
		lda		$4
		cmp		$6
		bne		palette_rotate_effect_itter_loop
	rts

;
;
; spawn_items
;
; Spawns items everywhere
;
;
spawn_items:
	lda		#0
	jsr		spawn_item
	lda		#1
	jsr		spawn_item
	lda		#2
	jsr		spawn_item
	lda		#3
	jsr		spawn_item
	lda		#4
	jsr		spawn_item
	rts

;
;
; spawn_item
;
; Spawns a single item
;
; Uses
;	$2 - $3	The item\'s address in the item RAM area
;
; Inputs
;	A		The item number to spawn
spawn_item_number_backup:			  .byte $00
spawn_item_x_backup:				  .byte $00
spawn_item_y_backup:				  .byte $00
spawn_item:
	sta		spawn_item_number_backup
	jsr		get_random_spawn_location
	stx		spawn_item_x_backup
	sty		spawn_item_y_backup
	
	; Calculate the item\'s RAM address
	lda		spawn_item_number_backup
	asl
	asl
	asl
	clc
	adc		#<item_ram
	sta		$2
	lda		#0
	adc		#>item_ram
	sta		$3
	
	; X location
	ldy		#0
	lda		spawn_item_x_backup
	lsr
	lsr
	lsr
	lsr
	sta		($2),y
	iny
	lda		spawn_item_x_backup
	and		#$0f
	sta		($2),y
	
	; Y location
	iny
	lda		spawn_item_y_backup
	lsr
	lsr
	lsr
	lsr
	sta		($2),y
	iny
	lda		spawn_item_y_backup
	and		#$0f
	sta		($2),y
	
	rts

;
;
; get_random_spawn_location
;
; Gets a random spawn location for a given item 
;
; Uses
;	$2 - $3	The base address in the spawn location table
;
; Inputs
;	A		The item number to spawn
;
; Outputs
;	X		The X location byte
;	Y		The Y location bytes
get_random_spawn_location:
	; Calculate the base address in the spawn location table
	asl
	asl
	asl
	asl
	asl
	clc
	adc		#<spawn_points
	sta		$2
	lda		#0
	adc		#>spawn_points
	sta		$3
	
	; Get a random number between 0 and 15
	lda		random
	and		#$0f
	

	; Convert to the offset
	asl
	

	; X location byte
	tay	
	lda		($2),y
	tax
	
	; Y location bytes
	iny
	lda		($2),y
	tay
	
	rts

;
;
; End of Game
;
;
end_of_game_count:		  .byte $00
end_of_game:
	; Does the player have the crown and death star?
	ldx		#0
	lda		item_flags,x
	beq		end_of_game_loose
	inx
	lda		item_flags,x
	beq		end_of_game_loose
	
	; Win routine
	lda		#1
	ldx		#32
	jsr		palette_rotate_effect
	jmp		end
	
	; Loose routine
end_of_game_loose:
	lda		#0
	sta		end_of_game_count
end_of_game_loose_loop:
		lda		#7
		ldx		#1
		jsr		palette_rotate_effect
		lda		#9
		ldx		#1
		jsr		palette_rotate_effect
		inc		end_of_game_count
		lda		end_of_game_count
		cmp		#8
		bne		end_of_game_loose_loop
	lda		#7
	ldx		#1
	jsr		palette_rotate_effect
	jmp		end

;
;
; move_player
;
; Handles moving the player to a new location
;
; Inputs
;	A		The new direction code of the player
;			0 = Down, 1 = Right, 2 = Left, 3 = Up
;	X		The new screen X location of the player
;	Y		The new screen Y location of the player
move_player_direction:		  .byte $00
move_player_x:				  .byte $00
move_player_y:				  .byte $00
move_player:
	sta		move_player_direction
	stx		move_player_x
	sty		move_player_y
	

	; Check for Out of Bounds move
	lda		move_player_x
	bpl		move_player_bounds_1	; Went off left side of screen
		dec		player_map_x
		lda		#7
		sta		move_player_x
		jsr		update_map_screen
move_player_bounds_1:
	cmp		#8
	bmi		move_player_bounds_2	; Went off right side of screen
		inc		player_map_x
		lda		#0
		sta		move_player_x
		jsr		update_map_screen
move_player_bounds_2:
	lda		move_player_y
	bpl		move_player_bounds_3	; Went off top side of screen
		dec		player_map_y
		lda		#7
		sta		move_player_y
		jsr		update_map_screen
move_player_bounds_3:
	cmp		#8
	bmi		move_player_bounds_4	; Went off bottom side of screen
		inc		player_map_y
		lda		#0
		sta		move_player_y
		jsr		update_map_screen
move_player_bounds_4:

	; Clear previous location
	ldx		player_screen_x
	ldy		player_screen_y
	jsr		clear_screen_position

	; Test location for moveability
	; Calculate screen RAM offset to get tile color
	lda		move_player_y
	asl
	asl
	asl
	ora		move_player_x
	tay
	ldx		screen_ram,y		; Now X is the tile color
	lda		tile_flags,x		; Load the tile flags into A
	lsr
	bcs		move_player_do_move	; If the walkable flag is set, continue
		jmp		move_player_skip_move
move_player_do_move:
		ldx		move_player_x
		ldy		move_player_y
		stx		player_screen_x
		sty		player_screen_y
move_player_skip_move:
	
	; Update the position and sprite
	ldx		player_screen_x
	ldy		player_screen_y
	lda		player_sprite
	and		#$fc
	ora		move_player_direction
	sta		player_sprite
	jsr		blit_sprite
	
	; Check for Items and Act on Them
	lda		player_screen_x
	cmp		screen_item_x
	bne		move_player_skip_item
	lda		player_screen_y
	cmp		screen_item_y
	bne		move_player_skip_item
	jsr		take_screen_item
move_player_skip_item:

	; At end of game check
	lda		player_map_x
	cmp		#$08
	bne		move_player_skip_eog
	lda		player_map_y
	cmp		#$0d
	bne		move_player_skip_eog
	lda		player_screen_x
	cmp		#$03
	bne		move_player_skip_eog
	lda		player_screen_y
	cmp		#$04
	bne		move_player_skip_eog
	jsr		end_of_game
move_player_skip_eog:
	
	rts

;
;
; take_screen_item
;
; Called when the player has stepped onto the item on this screen.
;
; Uses
;	$2 - $3	Base pointer into the item patch table
;	$4 - $5	Patch pointer
;	$6		Temp
take_screen_item_idx:			  .byte $00
take_screen_item_patch:			  .byte $00
take_screen_item:
	; Remove the item from the screen
	lda		screen_item_idx
	sta		take_screen_item_idx
	lda		#$ff
	sta		screen_item_x
	sta		screen_item_y
	sta		screen_item_idx
	
	; Remove the item from the map
	lda		take_screen_item_idx
	asl
	asl
	asl
	tax
	lda		#$ff
	sta		item_ram,x
	inx
	sta		item_ram,x
	inx
	sta		item_ram,x
	inx
	sta		item_ram,x
	inx
	sta		item_ram,x
	
	; Calculate the base offset into the item patch table
	lda		take_screen_item_idx
	asl
	asl
	asl
	asl
	asl
	clc
	adc		#<item_patch_data
	sta		$2
	lda		#0
	adc		#>item_patch_data
	sta		$3
	
	; Itterate through all patches
	lda		#0
	ldy		#0
	sta		take_screen_item_patch
take_screen_item_patch_loop:
		; Validate the patch is valid
		lda		($2),y
		bpl		take_screen_item_valid_patch
			; Skip over this patch
			iny
			iny
			iny
			iny
			jmp		take_screen_item_next_patch
take_screen_item_valid_patch:
		
		; Calculate the patch pointer
		lda		($2),y
		tax
		lda		item_patch_table_lo,x
		sta		$4
		lda		item_patch_table_hi,x
		sta		$5
		iny
		clc
		lda		($2),y
		adc		$4
		sta		$4
		iny
		lda		($2),y
		adc		$5
		sta		$5
		iny
		
		; Do the patch
		lda		($2),y
		iny
		sty		$6
		ldy		#0
		sta		($4),y
		ldy		$6

		; Go to the next patch
take_screen_item_next_patch:
		inc		take_screen_item_patch
		lda		take_screen_item_patch
		cmp		#8
		bne		take_screen_item_patch_loop
	
	lda		#1
	ldx		#16
	jsr		palette_rotate_effect
	jsr		render_screen
	lda		player_sprite
	ldx		player_screen_x
	ldy		player_screen_y
	jsr		blit_sprite
	
	rts

;
;
; clear_screen_position
;
; Redraws a single location on the current screen
;
; Uses
;	$2 - $3	Frame buffer base address
;	$4		X location
;	$5		Y location
;	$6		Tile color
;
; Inputs
;	X		X location
;	Y		Y location
clear_screen_position:
	stx		$4
	sty		$5
	
	; Calculate the screen RAM offset and get the tile color
	tya
	asl
	asl
	asl
	ora		$4
	tay
	lda		screen_ram,y
	sta		$6
	
	; Calculate the framebuffer base offset
	asl		$4
	asl		$4
	asl		$5
	asl		$5
	lda		$5
	asl
	asl
	asl
	asl
	asl
	ora		$4
	sta		$2
	lda		$5
	lsr
	lsr
	lsr
	clc
	adc		#>frame_buffer
	sta		$3
	

	; Itterate rows
	ldx		#0
	ldy		#0
clear_screen_position_row_loop:
		lda		$6
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		tya
		clc
		adc		#29
		tay
		inx
		cpx		#4
		bne		clear_screen_position_row_loop
	
	rts

;
;
; blit_player
;
; Blits the player\'s sprite to the screen
;
;
blit_player:
	lda		player_sprite
	ldx		player_screen_x
	ldy		player_screen_y
	jsr		blit_sprite
	rts

;
;
; update_map_screen
;
; Loads and renders the player\'s current map screen
;
;
update_map_screen:
	; Render the screen
	ldx		player_map_x
	ldy		player_map_y
	jsr		load_map_screen
	jsr		render_screen
	rts

;
;
; blit_sprite
;
; Blits a sprite to the frame buffer
;
; Uses
;
; Inputs
;	A		Sprite number
;	X		X screen coordinate
;	Y		Y screen coordinate
blit_sprite:
	; Set up framebuffer offset
	sta		$6
	tya
	asl
	asl
	tay			; Now we have the pixel row, so make the row base offset
	asl
	asl
	asl
	asl
	asl
	sta		$2
	tya
	lsr
	lsr
	lsr
	clc
	adc		#>frame_buffer
	sta		$3	; Now we have the base row offset, add the collumn offset
	txa
	asl
	asl
	ora		$2
	sta		$2
	
	; Set up sprite data pointer
	lda		#<sprite_data
	sta		$4
	lda		#>sprite_data
	sta		$5
	lda		$6
	asl
	asl
	asl
	clc
	adc		$4
	sta		$4
	lda		$5
	adc		#0
	sta		$5
	
	; Itterate bytes
	ldy		#0
	ldx		#0
blit_sprite_byte_loop:
		; Blat out the pixels
		lda		($4),y
		lsr
		lsr
		lsr
		lsr
		beq		blit_sprite_skip_pixel_1
			sta		($2,x)
blit_sprite_skip_pixel_1:
		inc		$2
		lda		($4),y
		and		#$0f
		beq		blit_sprite_skip_pixel_2
			sta		($2,x)
blit_sprite_skip_pixel_2:
		inc		$2
		; Step to next byte
		iny
		; If we are on an even byte, step the framebuffer pointer
		tya
		and		#$01
		bne		blit_sprite_fbinc_skip
			clc
			lda		$2
			adc		#28
			sta		$2
			lda		$3
			adc		#0
			sta		$3
blit_sprite_fbinc_skip:
		cpy		#8
		bne		blit_sprite_byte_loop
	rts

;
;
; load_map_screen
;
; Loads a map screen from the world map into the screen RAM
;
; Uses
;	$2 - $3	Item RAM pointer
;	$4		Temp variable
;	$5		Item Map X
;	$6		Item Screen X
;	$7		Item Map Y
;	$8		Item Screen Y
;	$9		Item Idx
;
; Calls load_screen
;
; Inputs
;	X		X world coordinate
;	Y		Y world coordinate
load_map_screen_x:			  .byte $00
load_map_screen_y:			  .byte $00
load_map_screen:
	; Wrap coordinates
	tya
	and		#$0f
	tay
	txa
	and		#$0f
	tax
	sty		load_map_screen_y
	stx		load_map_screen_x
	
	; Calculate the offset into the world map table
	tya
	asl
	asl
	asl
	asl
	stx		$2
	ora		$2
	tax
	
	; Get the screen number and load
	lda		world_map,x
	jsr		load_screen
	
	; Clear out the screen item variables
	lda		#$ff
	sta		screen_item_x
	sta		screen_item_y
	sta		screen_item_idx
	
	; Itterate through all items to see if we have an item on this
	; screen.
	lda		#<item_ram
	sta		$2
	lda		#>item_ram
	sta		$3
	ldx		#0
load_screen_item_loop:
		txa
		asl
		asl
		asl
		tay
		lda		($2),y
		sta		$5
		iny
		lda		($2),y
		sta		$6
		iny
		lda		($2),y
		sta		$7
		iny
		lda		($2),y
		sta		$8
		iny
		lda		($2),y
		sta		$9
		lda		$5
		cmp		load_map_screen_x
		bne		load_screen_item_skip
		lda		$7
		cmp		load_map_screen_y
		bne		load_screen_item_skip
		; Now we have an item that is on this map, put that item\'s
		; info into the screen item variables.
		lda		$6
		sta		screen_item_x
		lda		$8
		sta		screen_item_y
		lda		$9
		sta		screen_item_idx
		; And go to the next item
load_screen_item_skip:
		inx
		cpx		#8
		bne		load_screen_item_loop
	rts

;
;
; load_screen
;
; Decompresses a screen into the screen RAM
;
; Uses
;	$2 - $3	Map data pointer
;
; Inputs
; 	A		Screen number to load
load_screen:
	; Calculate base screen data offset
	tay
	asl
	asl
	asl
	asl
	asl
	sta		$2
	tya
	lsr
	lsr
	lsr
	sta		$3
	clc
	lda		$2
	adc		#<screen_data
	sta		$2
	lda		$3
	adc		#>screen_data
	sta		$3
	

	; Itterate through all bytes
	ldy		#0
	ldx		#0
load_screen_byte_loop:
		lda		($2),y
		lsr
		lsr
		lsr
		lsr
		sta		screen_ram,x
		inx
		lda		($2),y
		and		#$0f
		sta		screen_ram,x
		inx
		iny
		cpy		#32
		bne		load_screen_byte_loop	
	rts

;
;
; render_screen
;
; Renders the entire screen from RAM to the display as well as any
; item that may be present.
;
; Uses $2 - $3
;
;
render_screen:
	; Set up the base screen offset
	lda		#<frame_buffer
	sta		$2
	lda		#>frame_buffer
	sta		$3

	; Itterate through all tiles
	ldx		#0
render_screen_tile_loop:
		; Blat out the pixels
		ldy		#0
		lda		screen_ram,x
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		tya
		clc
		adc		#29
		tay
		lda		screen_ram,x
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		tya
		clc
		adc		#29
		tay
		lda		screen_ram,x
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		tya
		clc
		adc		#29
		tay
		lda		screen_ram,x
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		iny
		sta		($2),y
		; Go to the next tile
		inx
		; Update the screen base offset
		clc
		lda		$2
		adc		#4
		sta		$2
		lda		$3
		adc		#0
		sta		$3
		; If we have gone to a new row, jump ahead
		txa
		and		#$07
		bne		render_screen_skip_row_adjust
			clc
			lda		$2
			adc		#96
			sta		$2
			lda		$3
			adc		#0
			sta		$3
render_screen_skip_row_adjust:
		cpx		#64
		bne		render_screen_tile_loop
	
	; Render the on-screen item if one is present
	lda		screen_item_idx
	bmi		render_screen_skip_item
	; Add 4 to the item number to get the item sprite number
	clc
	adc		#4
	ldx		screen_item_x
	ldy		screen_item_y
	jsr		blit_sprite
	
render_screen_skip_item:
	rts


;
;
; DATA
;
;


world_map:
;   0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
  .byte $04,$02,$00,$02,$00,$02,$00,$07,$17,$0f,$18,$19,$19,$19,$1a,$14 ; 0
  .byte $04,$03,$08,$03,$05,$01,$ff,$0b,$16,$0e,$15,$14,$17,$0f,$13,$12 ; 1
  .byte $ff,$01,$01,$06,$01,$06,$ff,$0c,$0f,$0f,$13,$12,$1b,$1c,$0e,$11 ; 2
  .byte $ff,$06,$0a,$00,$09,$00,$ff,$0d,$0e,$0e,$10,$11,$16,$1d,$19,$1e ; 3
  .byte $ff,$ff,$ff,$ff,$45,$43,$43,$43,$40,$3d,$36,$3a,$2c,$25,$25,$1f ; 4
  .byte $ff,$ff,$ff,$ff,$45,$43,$40,$43,$37,$3e,$37,$3b,$2d,$2f,$30,$21 ; 5
  .byte $ff,$ff,$ff,$ff,$46,$43,$37,$43,$41,$38,$38,$3c,$2e,$26,$27,$20 ; 6
  .byte $ff,$ff,$ff,$ff,$47,$44,$44,$44,$42,$3f,$39,$39,$31,$28,$29,$21 ; 7
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$32,$22,$22,$20 ; 8
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$33,$2a,$2b,$20 ; 9
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$32,$28,$29,$21 ; a
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$33,$22,$22,$20 ; b
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$48,$4f,$4f,$4e,$32,$26,$27,$21 ; c
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$49,$4a,$50,$51,$34,$28,$29,$21 ; d
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$4b,$4c,$4e,$4b,$32,$22,$22,$20 ; e
  .byte $ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$4a,$4d,$4a,$4d,$35,$24,$24,$23 ; f

screen_data:
;   0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
  .byte $55,$55,$55,$55,$55,$dd,$dd,$55,$dd,$99,$d9,$d9,$99,$99,$99,$99,$99,$99,$99,$99,$9d,$d9,$99,$dd,$55,$dd,$dd,$55,$55,$55,$55,$55 ; $00 Forest, E/W Path
  .byte $55,$d9,$9d,$55,$55,$99,$9d,$55,$5d,$99,$9d,$d5,$5d,$99,$99,$d5,$5d,$9d,$99,$d5,$5d,$99,$99,$d5,$55,$d9,$99,$55,$55,$d9,$9d,$55 ; $01 Forest, N/S Path
  .byte $55,$55,$55,$55,$55,$dd,$dd,$55,$d9,$99,$99,$9d,$99,$d9,$99,$99,$99,$99,$99,$99,$d9,$99,$d9,$99,$5d,$99,$99,$d5,$55,$d9,$9d,$55 ; $02 Forest, E/W/S Path
  .byte $55,$d9,$9d,$55,$5d,$99,$99,$55,$99,$99,$99,$d5,$99,$9d,$99,$d5,$d9,$99,$99,$d5,$dd,$99,$99,$d5,$5d,$d9,$9d,$55,$55,$dd,$9d,$55 ; $03 Forest, N/S/W Path
  .byte $55,$55,$55,$55,$55,$dd,$dd,$55,$5d,$d9,$99,$dd,$5d,$99,$99,$99,$5d,$99,$d9,$99,$5d,$d9,$99,$d9,$55,$dd,$dd,$55,$55,$55,$55,$55 ; $04 Forest, Dead End E
  .byte $55,$55,$55,$55,$55,$d9,$dd,$55,$5d,$9d,$9d,$d5,$5d,$d9,$d9,$d5,$5d,$d9,$99,$d5,$5d,$9d,$d9,$d5,$55,$d9,$9d,$55,$55,$dd,$99,$55 ; $05 Forest, Dead End S
  .byte $55,$99,$9d,$55,$55,$99,$9d,$55,$5d,$d9,$99,$d5,$5d,$99,$d9,$d5,$5d,$d9,$99,$d5,$5d,$9d,$9d,$d5,$55,$dd,$dd,$55,$55,$55,$55,$55 ; $06 Forest, Dead End N
  .byte $55,$55,$55,$55,$55,$dd,$dd,$55,$dd,$9d,$9d,$d5,$d9,$99,$d9,$d5,$9d,$9d,$99,$d5,$d9,$d9,$9d,$d5,$5d,$dd,$dd,$d5,$55,$dd,$dd,$55 ; $07 Forest, Path W/S
  .byte $55,$55,$55,$55,$55,$dd,$dd,$d5,$5d,$d9,$99,$dd,$5d,$9d,$99,$99,$5d,$99,$99,$d9,$5d,$99,$d9,$99,$55,$d9,$99,$d5,$55,$d9,$9d,$55 ; $08 Forest, Path E/S
  .byte $55,$d9,$9d,$55,$5d,$d9,$99,$55,$dd,$99,$d9,$d5,$99,$9d,$99,$d5,$99,$99,$99,$d5,$dd,$99,$9d,$d5,$5d,$dd,$dd,$55,$55,$55,$55,$55 ; $09 Forest, Path N/W
  .byte $55,$d9,$9d,$55,$5d,$99,$99,$d5,$5d,$9d,$9d,$9d,$5d,$99,$99,$99,$5d,$d9,$99,$99,$5d,$dd,$99,$dd,$5d,$dd,$dd,$55,$55,$55,$55,$55 ; $0a Forest, Path N/E
  .byte $55,$d9,$dd,$55,$55,$9d,$d9,$d5,$5d,$dd,$dd,$d5,$55,$9d,$9d,$95,$55,$dd,$d9,$55,$55,$dd,$dd,$55,$5d,$d9,$dd,$55,$5d,$dd,$dd,$55 ; $0b Forest, River Transition 1
  .byte $5d,$dd,$dd,$55,$5d,$dd,$d9,$d5,$5d,$dd,$d9,$dd,$5d,$9d,$d9,$99,$5d,$dd,$99,$ee,$55,$dd,$99,$ee,$55,$dd,$9e,$ee,$55,$5d,$9e,$e6 ; $0c Forest, River Transition 2
  .byte $55,$5d,$9e,$e6,$55,$5d,$9e,$ee,$55,$5d,$9e,$ee,$55,$55,$d9,$ee,$55,$55,$d9,$99,$55,$55,$59,$9d,$55,$55,$55,$d5,$55,$55,$55,$55 ; $0d Forest, River Transition 3
  .byte $66,$66,$66,$66,$e6,$6e,$e6,$6e,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$99,$99,$99,$99,$dd,$9d,$dd,$9d,$55,$d5,$55,$d5,$55,$55,$55,$55 ; $0e River, E/W Channel Bottom
  .byte $55,$55,$55,$55,$55,$55,$55,$d5,$d9,$dd,$dd,$dd,$99,$99,$99,$99,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$e6,$ee,$66,$ee,$66,$66,$66,$66 ; $0f River, E/W Channel Top
  .byte $66,$66,$66,$66,$e6,$6e,$e6,$6e,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$9e,$ee,$99,$e9,$de,$ff,$ff,$9d,$5f,$ff,$ff,$f5,$11,$ff,$ff,$11 ; $10 River, White Transition
  .byte $6e,$ee,$ed,$55,$ee,$ee,$ed,$d5,$ee,$ee,$e9,$d5,$ee,$ee,$99,$d5,$ee,$e9,$9d,$d5,$dd,$99,$dd,$55,$5d,$dd,$d5,$55,$55,$55,$55,$55 ; $11 River, N/W Channel
  .byte $ee,$ee,$ed,$55,$ee,$ee,$9d,$55,$ee,$e9,$9d,$55,$ee,$ee,$99,$d5,$ee,$ee,$99,$d5,$ee,$e9,$9d,$55,$ee,$ee,$9d,$55,$6e,$ee,$ed,$55 ; $12 River, N/S Channel Right
  .byte $55,$d9,$ee,$ee,$55,$99,$ee,$ee,$d9,$ee,$ee,$ee,$99,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$e6,$6e,$e6,$ee,$66,$66,$66,$66 ; $13 River, N/W Channel Join E
  .byte $55,$55,$55,$55,$5d,$dd,$d5,$55,$d9,$99,$9d,$d5,$e9,$99,$99,$d5,$ee,$ee,$99,$d5,$ee,$ee,$e9,$d5,$ee,$ee,$e9,$55,$ee,$ee,$ed,$55 ; $14 River, S/W Channel
  .byte $6e,$ee,$9d,$55,$ee,$ee,$99,$d5,$ee,$ee,$e9,$9d,$ee,$ee,$ee,$99,$99,$ee,$ee,$ee,$d9,$9e,$ee,$ee,$5d,$99,$ee,$ee,$55,$d9,$ee,$ee ; $15 River, SE/NW Gap
  .byte $55,$de,$ee,$e6,$55,$d9,$ee,$ee,$5d,$99,$ee,$ee,$5d,$99,$9e,$ee,$5d,$99,$99,$9e,$5d,$9d,$d9,$dd,$55,$d5,$5d,$d5,$55,$55,$55,$55 ; $16 River, N/E Channel
  .byte $55,$55,$55,$55,$55,$5d,$dd,$d5,$55,$dd,$dd,$dd,$5d,$dd,$99,$9e,$5d,$d9,$9e,$ee,$5d,$d9,$ee,$ee,$5d,$d9,$ee,$ee,$55,$de,$ee,$e6 ; $17 River, E/S
  .byte $55,$55,$55,$55,$5d,$dd,$dd,$dd,$dd,$dd,$99,$99,$99,$99,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$99,$ee,$ee,$e9,$dd,$6e,$ee,$9d,$55 ; $18 River, Gulch Transition West
  .byte $55,$55,$55,$55,$dd,$99,$dd,$dd,$99,$ee,$99,$99,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$99,$99,$9e,$e9,$dd,$dd,$d9,$9d,$55,$55,$55,$55 ; $19 River, Gulch
  .byte $55,$55,$55,$55,$dd,$dd,$dd,$55,$99,$99,$99,$dd,$ee,$ee,$99,$99,$ee,$ee,$e9,$9e,$99,$ee,$ee,$ee,$dd,$9e,$ee,$ee,$55,$d9,$ee,$ee ; $1a River, Gulch Transition East
  .byte $55,$d9,$ee,$e6,$55,$d9,$9e,$ee,$5d,$d9,$99,$ee,$5d,$99,$ee,$ee,$55,$9e,$ee,$ee,$55,$9e,$ee,$e6,$5d,$d9,$ee,$66,$55,$d9,$ee,$e6 ; $1b River, Confluance SW
  .byte $66,$66,$66,$66,$e6,$6e,$e6,$6e,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$ee,$99,$6e,$ee,$e9,$9d,$6e,$ee,$99,$d5,$6e,$e9,$99,$d5 ; $1c River, Confluance SE
  .byte $6e,$e9,$99,$d5,$ee,$97,$77,$dd,$ee,$97,$77,$d9,$ee,$e9,$99,$9e,$ee,$ee,$ee,$ee,$dd,$d9,$99,$99,$55,$5d,$dd,$dd,$55,$55,$55,$55 ; $1d River, Gluch Transition South by West
  .byte $55,$55,$56,$66,$dd,$d9,$66,$66,$99,$9e,$ee,$66,$ee,$ee,$e7,$e6,$ee,$ee,$77,$e8,$9e,$e7,$7e,$e8,$d9,$77,$77,$88,$57,$77,$78,$88 ; $1e River, Desert Transition
  .byte $88,$77,$77,$88,$87,$77,$78,$88,$77,$77,$78,$88,$77,$77,$77,$88,$77,$77,$78,$88,$77,$77,$88,$88,$77,$77,$78,$88,$77,$77,$77,$88 ; $1f Desert, Entrance
  .byte $77,$77,$77,$88,$77,$77,$78,$88,$77,$87,$88,$88,$77,$78,$88,$88,$77,$77,$88,$88,$77,$77,$88,$88,$78,$77,$78,$88,$77,$77,$77,$88 ; $20 Desert, East Wall 1
  .byte $77,$77,$77,$88,$77,$77,$78,$88,$77,$77,$88,$88,$77,$77,$78,$88,$78,$77,$77,$88,$77,$77,$78,$88,$77,$77,$78,$88,$77,$77,$77,$88 ; $21 Desert, East Wall 2
  .byte $77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77 ; $22 Desert, Center
  .byte $77,$77,$77,$88,$77,$87,$78,$88,$78,$77,$88,$88,$77,$77,$88,$88,$77,$78,$88,$88,$78,$88,$88,$88,$88,$88,$88,$88,$88,$88,$88,$88 ; $23 Desert, SE Wall
  .byte $77,$77,$77,$77,$77,$77,$77,$77,$77,$78,$77,$87,$77,$77,$77,$77,$77,$77,$78,$77,$78,$87,$77,$77,$88,$88,$88,$88,$88,$88,$88,$88 ; $24 Desert, South Wall
  .byte $88,$88,$88,$88,$88,$88,$88,$88,$78,$88,$87,$87,$77,$88,$77,$77,$77,$77,$77,$77,$77,$77,$78,$77,$77,$87,$77,$77,$77,$77,$77,$77 ; $25 Desert, North Wall
  .byte $77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$78,$77,$77,$78,$88,$77,$77,$78,$88,$77,$77,$88,$88 ; $26 Desert, Rock Formation 1, NW
  .byte $77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$87,$77,$77,$77,$88,$77,$77,$77,$88,$87,$77,$77,$88,$87,$77,$77 ; $27 Desert, Rock Formation 1, NE
  .byte $77,$77,$88,$88,$77,$77,$78,$88,$77,$77,$77,$88,$77,$77,$77,$78,$77,$77,$77,$88,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77 ; $28 Desert, Rock Formation 1/2, SW
  .byte $88,$87,$77,$77,$88,$77,$77,$77,$88,$87,$77,$77,$88,$87,$77,$77,$87,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77,$77 ; $29 Desert, Rock Formation 1/2, SE
  .byte $77,$77,$77,$77,$78,$77,$77,$87,$78,$88,$78,$88,$77,$88,$88,$88,$77,$78,$87,$78,$77,$88,$77,$77,$77,$88,$87,$78,$77,$77,$88,$88 ; $2a Desert, Rock Formation 2, NW
  .byte $77,$77,$77,$77,$77,$78,$88,$87,$87,$88,$87,$77,$88,$88,$77,$87,$88,$87,$78,$87,$77,$77,$88,$87,$88,$88,$88,$77,$88,$87,$77,$77 ; $2b Desert, Rock Formation 2, NE
  .byte $18,$88,$88,$88,$18,$78,$88,$88,$17,$77,$88,$87,$11,$77,$78,$77,$ff,$17,$77,$77,$11,$77,$77,$87,$17,$78,$77,$77,$17,$77,$77,$77 ; $2c Desert, White Wall N/NE
  .byte $17,$77,$77,$77,$17,$71,$11,$77,$17,$11,$f1,$17,$11,$1f,$ff,$11,$ff,$ff,$ff,$ff,$11,$1f,$ff,$11,$17,$1f,$ff,$17,$17,$1f,$ff,$17 ; $2d Desert, White Bastion 1, N
  .byte $17,$1f,$ff,$17,$17,$1f,$ff,$17,$11,$1f,$ff,$17,$ff,$ff,$ff,$17,$11,$1f,$ff,$17,$17,$11,$f1,$17,$17,$71,$11,$77,$17,$77,$77,$77 ; $2e Desert, White Bastion 1, S
  .byte $77,$77,$77,$77,$71,$11,$11,$11,$71,$ff,$ff,$ff,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$ff,$ff,$ff,$71,$11,$11,$11,$77,$77,$77,$77 ; $2f Desert, White Bastion 2, W
  .byte $77,$77,$77,$77,$11,$11,$11,$17,$ff,$ff,$ff,$17,$ff,$ff,$ff,$17,$ff,$ff,$ff,$17,$ff,$ff,$ff,$17,$11,$11,$11,$17,$77,$77,$77,$77 ; $30 Desert, White Bastion 2, E
  .byte $17,$77,$77,$77,$17,$77,$77,$77,$11,$77,$77,$77,$ff,$17,$77,$77,$11,$77,$77,$77,$17,$77,$77,$77,$17,$77,$77,$77,$17,$77,$77,$77 ; $31 Desert, White Wall S/SE
  .byte $b7,$77,$77,$77,$b7,$77,$77,$77,$b7,$77,$77,$77,$b7,$77,$77,$77,$b7,$77,$77,$77,$b7,$77,$77,$77,$b7,$77,$77,$77,$b7,$77,$77,$77 ; $32 Desert, Black Wall
  .byte $b7,$77,$77,$77,$b7,$77,$77,$77,$bb,$bb,$bb,$77,$ff,$ff,$fb,$77,$fb,$bb,$fb,$77,$ff,$ff,$fb,$77,$bb,$bb,$bb,$77,$b7,$77,$77,$77 ; $33 Desert, Black Bastion
  .byte $b7,$77,$77,$77,$bb,$bb,$f7,$77,$bb,$bb,$ff,$77,$fb,$ff,$ff,$77,$bb,$bb,$ff,$77,$bb,$bb,$f7,$77,$b7,$77,$77,$77,$b7,$77,$77,$77 ; $34 Desert, Black Gate
  .byte $b7,$77,$77,$77,$b8,$78,$77,$77,$b8,$77,$87,$77,$b8,$87,$88,$77,$b8,$88,$77,$77,$b8,$88,$88,$77,$b8,$88,$88,$88,$b8,$88,$88,$88 ; $35 Desert, Black Wall SW
  .byte $11,$ff,$ff,$11,$1d,$ff,$ff,$d1,$1d,$df,$fd,$d1,$1d,$df,$fd,$d1,$1d,$ff,$ff,$d1,$11,$1f,$f1,$11,$11,$11,$11,$11,$11,$1f,$f1,$11 ; $36 White, Gate
  .byte $11,$1f,$f1,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11,$11,$11,$11,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11 ; $37 White, W/E w/ N Door
  .byte $11,$11,$11,$11,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$11,$11 ; $38 White, S Snail
  .byte $1f,$f1,$11,$11,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$ff,$f1,$1f,$ff,$1f,$f1,$1f,$f1,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$11,$11,$11,$11 ; $39 White, N Snail w/ E/W Doors
  .byte $11,$11,$11,$11,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$ff,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$11,$11 ; $3a White, S Snail w/ E Door
  .byte $1f,$f1,$11,$11,$ff,$f1,$1f,$f1,$ff,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$ff,$ff,$f1,$1f,$f1,$ff,$f1,$1f,$f1,$11,$11,$1f,$f1 ; $3b White, 11x5
  .byte $11,$11,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$ff,$1f,$ff,$ff,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$1f,$f1,$11,$11 ; $3c White, 11x6
  .byte $11,$11,$11,$11,$ff,$ff,$ff,$f1,$ff,$ff,$ff,$f1,$11,$11,$1f,$f1,$11,$11,$1f,$f1,$ff,$f1,$1f,$f1,$ff,$f1,$1f,$f1,$1f,$f1,$1f,$f1 ; $3d White, Dual W/S Hall
  .byte $1f,$f1,$1f,$f1,$ff,$f1,$1f,$ff,$ff,$f1,$1f,$ff,$11,$11,$11,$11,$11,$11,$11,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11 ; $3e White, W/E, Dual N Hall
  .byte $1f,$f1,$11,$11,$ff,$f1,$1f,$f1,$ff,$f1,$1f,$f1,$11,$11,$1f,$ff,$11,$11,$1f,$f1,$ff,$ff,$ff,$f1,$ff,$ff,$ff,$f1,$11,$11,$11,$11 ; $3f White, Dual W, N w/ E Door
  .byte $11,$11,$11,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$1f,$f1,$11,$11,$1f,$f1,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$1f,$f1,$11 ; $40 White, Dual W/E, S Hall
  .byte $11,$11,$11,$11,$ff,$ff,$ff,$f1,$ff,$ff,$ff,$f1,$11,$11,$1f,$f1,$11,$11,$1f,$f1,$ff,$ff,$ff,$f1,$ff,$ff,$ff,$f1,$11,$1f,$f1,$11 ; $41 White, Daul W, S Hall
  .byte $11,$1f,$f1,$11,$1f,$ff,$ff,$ff,$1f,$ff,$ff,$ff,$1f,$f1,$11,$11,$1f,$f1,$11,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11 ; $42 White, W, Dual E, N Hall
  .byte $11,$11,$11,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11,$11,$11,$11,$11,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11 ; $43 White, Dual E/W Hall
  .byte $11,$11,$11,$11,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$ff,$11,$11,$11,$11 ; $44 White, Cell
  .byte $11,$11,$11,$11,$1f,$ff,$ff,$ff,$1f,$ff,$ff,$ff,$1f,$ff,$11,$11,$1f,$ff,$11,$11,$1f,$ff,$11,$ff,$1f,$ff,$11,$ff,$11,$11,$11,$11 ; $45 White, E Snail
  .byte $11,$11,$11,$11,$1f,$ff,$ff,$ff,$1f,$ff,$ff,$ff,$1f,$f1,$11,$11,$1f,$f1,$11,$11,$1f,$f1,$1f,$ff,$1f,$f1,$1f,$ff,$1f,$f1,$11,$11 ; $46 White, E/S Hall
  .byte $1f,$f1,$11,$11,$1f,$ff,$ff,$f1,$1f,$ff,$ff,$f1,$11,$11,$11,$11,$11,$11,$11,$11,$1f,$ff,$ff,$ff,$1f,$ff,$ff,$ff,$11,$11,$11,$11 ; $47 White, Cell End
  .byte $bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$ff,$ff,$bb,$ff,$fb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb ; $48 Black, E
  .byte $bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$fb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb ; $49 Black, S
  .byte $bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$ff,$ff,$bb,$ff,$fb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb ; $4a Black, N/E
  .byte $bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$fb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb ; $4b Black, N/S
  .byte $bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$ff,$fb,$bb,$bb,$ff,$ff,$ff,$bb,$ff,$fb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb ; $4c Black, S/E
  .byte $bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$ff,$fb,$bb,$ff,$ff,$fb,$bb,$bb,$ff,$fb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb ; $4d Black, N/W
  .byte $bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$ff,$fb,$bb,$ff,$ff,$fb,$bb,$bb,$ff,$fb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb ; $4e Black, S/W
  .byte $bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$ff,$fb,$bb,$ff,$ff,$ff,$ff,$bb,$ff,$fb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb ; $4f Black, S/E/W
  .byte $bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$ff,$fb,$bb,$ff,$ff,$ff,$ff,$bb,$ff,$fb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb,$bb ; $50 Black, N/E/W
  .byte $bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$ff,$fb,$bb,$ff,$ff,$ff,$ff,$bb,$ff,$fb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb,$bb,$bf,$bb,$bb ; $51 Black, N/E/S/W

sprite_data:
  .byte $01,$cc,$11,$cc,$01,$cc,$01,$10 ; $00 Player Down
  .byte $00,$1c,$01,$1c,$01,$1c,$00,$10 ; $01 Player Right
  .byte $c1,$00,$c1,$10,$c1,$10,$01,$00 ; $02 Player Left
  .byte $01,$1c,$11,$11,$01,$1c,$01,$10 ; $03 Player Up
  .byte $00,$b0,$ee,$e0,$00,$0b,$0e,$ee ; $04 Flippers
  .byte $01,$10,$11,$00,$01,$10,$01,$00 ; $05 White Key
  .byte $0b,$0b,$bb,$bb,$00,$b0,$00,$00 ; $06 Black Key
  .byte $e0,$0e,$70,$07,$77,$77,$77,$77 ; $07 Crown
  .byte $00,$20,$22,$20,$02,$22,$02,$00 ; $08 Death Star
  .byte $0c,$c0,$22,$22,$c2,$2c,$02,$20 ; $09 Evil Guy

; Tile flags meanings
; 0		Walkable
tile_flags:
  .byte $00		; 0 Void, darkness, nothingness
  .byte $00		; 1 White Castle wall
  .byte $00		; 2 ???
  .byte $00		; 3 ???
  .byte $00		; 4 ???
  .byte $00		; 5 Tress, forest
  .byte $00		; 6 Deep water
  .byte $01		; 7 Desert sand
  .byte $00		; 8 Desert rocks
  .byte $01		; 9 Dirt, road
  .byte $00		; a ???
  .byte $00		; b Black Castle Wall
  .byte $00		; c ???
  .byte $01		; d Grass
  .byte $00		; e Shallow water
  .byte $01		; f Castle Floor

; Spawn points.
; 16 spawn points per area
; 2 bytes per spawn point
; First byte is X position, second is Y position
; Hi-nibble of byte is map position, Lo is Screen position
spawn_points:
  .byte $13,$13,$02,$13,$12,$35,$35,$15,$33,$23,$21,$12,$21,$36,$32,$32,$41,$31,$43,$24,$43,$11,$54,$25,$72,$03,$73,$16,$75,$25,$76,$36 ; Forest
  .byte $b5,$35,$b5,$24,$b3,$13,$92,$15,$82,$15,$84,$04,$91,$02,$f4,$02,$f3,$15,$f2,$25,$d4,$26,$c6,$13,$c5,$22,$c3,$33,$d7,$32,$e4,$35 ; River
  .byte $d2,$63,$d5,$85,$e4,$81,$e3,$97,$d5,$95,$e2,$a1,$d6,$a3,$c1,$91,$c6,$b4,$d2,$b2,$e5,$b4,$f3,$b2,$e3,$e3,$d1,$e5,$c3,$f3,$f2,$f2 ; Desert
  .byte $c1,$44,$c4,$52,$c3,$53,$c5,$53,$c4,$56,$c4,$61,$c4,$65,$c3,$64,$c5,$64,$d3,$53,$d5,$53,$d7,$53,$e0,$53,$e2,$53,$e4,$53,$c1,$73 ; White Bastions
  .byte $b6,$41,$b5,$51,$a6,$66,$a5,$71,$95,$71,$96,$66,$71,$71,$66,$71,$51,$71,$41,$75,$46,$72,$45,$66,$46,$54,$42,$55,$46,$46,$42,$45 ; White Castle

; Item patch data
; First byte is the table to patch, which indexes the item_patch_table_lo
; and item_patch_table_hi arrays.
; The tables are:
;	0	screen_data
;	1	sprite_data
;	2	tile_flags
;	3	object_flags
; Due to the lack of <> support for the   .byte statement, we populate
; these pointers at startup time.
; The second and third bytes are the offest from the begining of the
; table to patch.
; The fourth byte is the value to insert.
; Each item has 8 patches thay may occur.
; A table index of $ff indicates that this patch is not valid.
item_patch_data:
; Flippers
  .byte $02,$0e,$00,$01 ; Make shallow water walkable
  .byte $01,$06,$00,$0e ; Sprite, Down, Left Foot
  .byte $01,$07,$00,$e0 ; Sprite, Down, Right Foot
  .byte $01,$0f,$00,$e0 ; Sprite, Right, Foot
  .byte $01,$16,$00,$0e ; Sprite, Left, Foot
  .byte $01,$1e,$00,$0e ; Sprite, Up, Left Foot
  .byte $01,$1f,$00,$e0 ; Sprite, Up, Right Foot
  .byte $ff,$ff,$ff,$ff ; Fill
; White Key
  .byte $00,$d9,$06,$1f ; White castle gate 1
  .byte $00,$da,$06,$f1 ; White castle gate 2
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
; Black Key
  .byte $00,$8c,$06,$ff ; Black castle gate 1
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
; Crown
  .byte $01,$00,$00,$08 ; Sprite, Down, Head
  .byte $01,$09,$00,$8c ; Sprite, Right, Head
  .byte $01,$10,$00,$c8 ; Sprite, Left, Head
  .byte $01,$18,$00,$08 ; Sprite, Up, Head (Left)
  .byte $01,$19,$00,$8c ; Sprite, Up, Head (Right)
  .byte $03,$00,$00,$ff ; Crown object flag
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
; Death Star
  .byte $01,$02,$00,$21 ; Sprite, Down, Hand
  .byte $01,$0b,$00,$2c ; Sprite, Right, Hand
  .byte $01,$1a,$00,$21 ; Sprite, Up, Hand
  .byte $03,$01,$00,$ff ; Death Star object flag
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill
  .byte $ff,$ff,$ff,$ff ; Fill

item_patch_table_lo:
  .byte $00,$00,$00,$00
item_patch_table_hi:
  .byte $00,$00,$00,$00
 
   PROCESSOR 6502
   ORG $0600
; "Rorschach test"
; Not at all what it was supposed to be,
; but it turns out pretty cool and can
; create some interesting patterns.

  lda #8
  tax
dr:
  sta $3cb,x
  sta $40b,x
  dex
  bpl dr
  sta $3f3
  sta $3eb

  lda #1
  sta $3ec

  ldx #255
mk:
  lda $fe
  sta $1200,x
  lda $fe
  sta $1300,x
  lda $fe
  sta $1400,x
  lda $fe
  sta $1500,x
  dex
  cpx #$ff
  bne mk

; smooth it

  ldy #0
re:
  lda #1
  sta $3ec,y

  ldx #255
sm:
  lda $1201,x
  adc $11ff,x
  adc $1220,x
  adc $11e0,x
  lsr
  lsr
  sta $1200,x

  lda $1301,x
  adc $12ff,x
  adc $1320,x
  adc $12e0,x
  lsr
  lsr
  sta $1300,x

  lda $1401,x
  adc $13ff,x
  adc $1420,x
  adc $13e0,x
  lsr
  lsr
  sta $1400,x

  lda $1501,x
  adc $14ff,x
  adc $1520,x
  adc $14e0,x
  lsr
  lsr
  sta $1500,x

  dex
  cpx #$ff
  bne sm
  iny
  cpy #7
  bne re

  lda #1
  sta $3f0

  ;copy it

  clc
  ldx #255
cp:
  lda $1200,x
  lsr
  lsr
  tay
  lda colors,y
  sta $200,x

  lda $1300,x
  lsr
  lsr
  tay
  lda colors,y
  sta $300,x

  lda $1400,x
  lsr
  lsr
  tay
  lda colors,y
  sta $400,x

  lda $1500,x
  lsr
  lsr
  tay
  lda colors,y
  sta $500,x

  dex
  cpx #$ff
  bne cp
  rts

colors:
  .byte 0,0,0,0,0,$9,$9,1,1,0,0,0,0,0

   PROCESSOR 6502
   ORG $0600
; Skier for 6502asm.com by ern0@linkbroker.hu
; Beta Release 2008.11.29
; (Send e-mail for emulator version)

; Instructions:
;  Try to don\'t hit the trees
;  There are 4 game levels, 
;  (the last one is endless - yet)
; Game keys: 
;  \"n\" or \"j\" - left, 
;  \"m\" or \"k\" - right
; End keys: 
;  \'`\' - exit (left to \'1\', no ESC support)
;  other - restart game  
;
; TODO list:
;  Scroll speedup
;  On-screen instructions
;   - start 
;   - game over
;  Scoring (completion percent)
;  \"Game Completed\" situation
;  Some gameplay enhancments


; splash screen -------------------------------

; \'S\'
*=$224     
  .byte 1,1,1,1
*=$243
  .byte 1,1
*=$263
  .byte 1,1
*=$284
  .byte 1,1,1
*=$2a6
  .byte 1,1
*=$2c6
  .byte 1,1
*=$2e3
  .byte 1,1,1,1

; \'k\'
*=$229
  .byte 1,1
*=$249
  .byte 1,1
*=$269
  .byte 1,1,0,1,1
*=$289
  .byte 1,1,1
*=$2a9
  .byte 1,1,1,1
*=$2c9
  .byte 1,1,0,1,1
*=$2e9
  .byte 1,1,0,0,1

; \'i\'
*=$22f
  .byte 1,1
*=$26f
  .byte 1,1
*=$28f
  .byte 1,1
*=$2af
  .byte 1,1
*=$2cf
  .byte 1,1
*=$2ef
  .byte 1,1

; \'e\'
*=$273 
  .byte 1,1,1
*=$292
  .byte 1,1,0,1,1
*=$2b2
  .byte 1,1,1,1,1
*=$2d2
  .byte 1,1
*=$2f3
  .byte 1,1,1,1

; \'r\'
*=$278
  .byte 1,0,1,1
*=$298
  .byte 1,1,0,1
*=$2b8 
  .byte 1,1
*=$2d8
  .byte 1,1
*=$2f8
  .byte 1,1

; small \"BETA\"
*=$550
  .byte 5,5,0, 0, 5,5,5, 0, 5,5,5, 0, 0,5,0
*=$570
  .byte 5,0,5, 0, 5,0,0, 0, 0,5,0, 0, 5,0,5
*=$590
  .byte 5,5,0, 0, 5,5,5, 0, 0,5,0, 0, 5,5,5
*=$5b0
  .byte 5,0,5, 0, 5,0,0, 0, 0,5,0, 0, 5,0,5
*=$5d0
  .byte 5,5,0, 0, 5,5,5, 0, 0,5,0, 0, 5,0,5


; off-screen buffer ---------------------------

*=$600
  jmp start  ; don\'t use scroll area
  
  .byte 0,0,0,0,0        ; 1nd line (w/o jmp)
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0  ; 2nd line
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0  ; 3rd line
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0  ; 4th line
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  .byte 0,0,0,0,0,0,0,0
  
start: ;---------------------------------------

  ; delay params
  lda #40  ; inner cycle delay
  sta $d0
  lda #1   ; game delay
  sta $d1
  lda #60  ; car delay
  sta $d2
  
  jsr init
gcyc:
  jsr game
  jsr die
  cmp #$60
  bne gcyc
  jmp cleanup
  
init: ;----------------------------------------

  ; save and clear the leading jmp
  lda $601
  sta $61
  lda $602
  sta $62

  ; clear last key
  lda #0
  sta $ff
  
  jmp cls
  
cleanup: ;-------------------------------------
  
  lda #$4c  ; restore leading jmp
  sta $600
  lda $61
  sta $601
  lda $62 
  sta $602
  
  ; continue with cls

cls: ;-----------------------------------------
  
  ; clear the screen
  
  lda #0
  ldx #0
xcls:
  sta $200,x
  sta $300,x
  sta $400,x
  sta $500,x
  dex
  bne xcls

  ; clear off-screen area
  
  ldx #32
oxcls:
  sta $600,x
  dex
  bpl oxcls
  rts

game: ;----------------------------------------

  jsr rstlevel
  lda #$10
  sta $f0  ; skier position
  lda #0
  sta $f1  ; collision flag

  jsr cls
    
cycle: ;---------------------------------------

  lda $d4  ; generating freq
  sta $e1  ; scroll counter
  jsr nexttree

nogencyc:
  jsr scroll
  jsr skier
  lda $f1  ; collision
  beq noc
  rts
noc:  
  ldx #10
  jsr gdelay

  dec $d6
  bne nolevchg
  dec $d7
  bne nolevchg
  jsr inclevel

nolevchg:
  dec $e1
  bpl nogencyc
  
  jmp cycle
  
die: ;-------------------------------------

  ; bleeding
  
  lda #4
  sta $e1
locyc:
  jsr nexttree
  jsr scroll
  jsr skier
  jsr gdelay
  jsr scroll
  jsr skier
  jsr gdelay
  jsr scroll
  jsr skier
  jsr gdelay
  dec $e1
  bpl locyc
  
  ; car
  
  jsr cdelay
  jsr cdelay
  jsr cdelay
  jsr cdelay
  jsr cdelay
  jsr cdelay
  jsr cdelay
  
  lda #$6  ; blinker color
  sta $e2
  lda #0  ; start position
  sta $e3
  
  lda $f0  ; skier position
  clc
  adc #5
  sta $f2  ; as stop position
  cmp #25
  bvc carcyc
  lda #25
  sta $f2
  
carcyc:
  ldx $e3
  lda #1
  
  sta $320,x  ; column 1: front
  sta $340,x
  sta $360,x
  sta $380,x
  sta $3a0,x
  
  cpx #1
  bmi qdraw1
  
  sta $31f,x  ; column 2: window, blinker
  sta $37f,x
  sta $39f,x
  lda #$c
  sta $3bf,x
  lda #0
  sta $33f,x
  sta $35f,x
  
  lda $e2  ; blinker of column 2
  eor #4  ; blinker color change
  sta $e2
  sta $2ff,x
  ldy $f0
  lda #$a
  sta $300,y
  lda #$2
  sta $2ff,y
  sta $301,y

  cpx #2
  bmi qdraw1

  lda #0  ; column 3: window end
  sta $33e,x
  sta $35e,x
  sta $2fe,x
  lda #$c
  sta $3be,x
  lda #1   
  sta $31e,x
  sta $37e,x
  sta $39e,x
  
  cpx #3
  bmi qdraw1
  
  lda #0  ; column 4: pure white
  sta $3bd,x  ; erase wheel
  lda #1
  sta $31d,x  
  sta $33d,x
  sta $35d,x
  sta $37d,x
  sta $39d,x
  
  cpx #4
  bpl nqdraw1
qdraw1:  
  jmp qdraw
  
nqdraw1:
  lda #2  ; column 5: cross begins
  sta $35c,x
  lda #1
  sta $31c,x
  sta $33c,x
  sta $37c,x
  sta $39c,x
  
  cpx #5
  bmi qdraw
  
  lda #2  ; column 6: cross middle
  sta $33b,x
  sta $35b,x
  sta $37b,x
  lda #$c
  sta $3bb,x
  lda #1
  sta $31b,x
  sta $39b,x
  
  cpx #6
  bmi qdraw
  
  lda #2  ; column 7: cross ends
  sta $35a,x
  lda #$c
  sta $3ba,x
  lda #1
  sta $31a,x
  sta $33a,x
  sta $37a,x
  sta $39a,x
  
  cpx #7
  bmi qdraw
  
  lda #1  ; column 8: pure white
  sta $319,x  
  sta $339,x
  sta $359,x
  sta $379,x
  sta $399,x
  lda #0  
  sta $3b9,x  ; erase wheel

  cpx #8
  bmi qdraw
  
  sta $318,x  ; column 9: erase  
  sta $338,x
  sta $358,x
  sta $378,x
  sta $398,x

qdraw:  
  jsr cdelay
  inc $e3
  ldx $e3
  cpx $f2
  beq blinkin
  jmp carcyc
  
blinkin:
  lda #0
  sta $ff
  ldx $e3
  lda $e2  ; blinker of column 2
  eor #4  ; blinker color change
  sta $e2
  sta $2fe,x
  jsr cdelay
  jsr cdelay
  
  lda $ff  
  beq blinkin
  ldx #0
  stx $ff
  
  rts
  
skier: ;---------------------------------------

  ldx $f0  ; skier position
  lda $f1
  beq alive
  
  lda #$a
  sta $360,x
  sta $340,x
  lda #$2
  sta $33f,x
  sta $341,x
  rts
  
alive: 
  lda $340,x
  beq nocoll
  inc $f1
nocoll:
  lda #7
  sta $340,x
  lda #$c
  sta $33f,x
  sta $341,x

kchk:
  lda $ff
  beq nkey
  ldx #0
  stx $ff
                             
  and #1  
  bne way
  dec $f0
  dec $f0
way:
  inc $f0
  
  lda $f0 
  cmp #1 
  bpl nleft
  inc $f0
nleft:
  cmp #$1f
  bmi nkey
  dec $f0

nkey:
  lda #0
  sta $ff
  rts

rstlevel: ;------------------------------------

  ldx #0   ; easy
  stx $d3  ; store level
  jmp setlevel

inclevel: ;------------------------------------

  ldx $d3
  cpx #3  ; max level reached?
  beq rstlvlcntr
  inx
  stx $d3

setlevel: ;------------------------------------

  lda freqtab,x
  sta $d4  ; freqency of the trees
  lda colortab,x
  sta $d5  ; color of the trees

rstlvlcntr:
  lda #0
  sta $d6
  lda #2   ; level change speed (higher=slower)
  sta $d7
  
  rts
  
; level data ----------------------------------

freqtab:
  .byte 22,17,12,7
colortab:
  .byte $5,$d,$8,$4

nexttree: ;------------------------------------

  lda $fe
  lsr
  lsr
  lsr
  
  clc
  adc #2
  cmp #30
  bmi painttree
  rts

painttree:
  tax
  lda $d5
  sta $600,x  ; off-screen
  
  sta $61f,x  ; line 2
  sta $620,x
  sta $621,x
  
  sta $63e,x  ; line 3
  sta $63f,x
  sta $640,x
  sta $641,x
  sta $642,x
  
  sta $660,x  ; line 4
  rts
  
scroll: ;--------------------------------------

  ldx #$1f
scyc:
  lda $220,x
  sta $200,x
  lda $240,x
  sta $220,x
  lda $260,x
  sta $240,x
  lda $280,x
  sta $260,x
  lda $2a0,x
  sta $280,x
  lda $2c0,x
  sta $2a0,x
  lda $2e0,x
  sta $2c0,x
  lda $300,x
  sta $2e0,x
  
  lda $320,x
  sta $300,x
  lda $340,x
  sta $320,x
  lda $360,x
  sta $340,x
  lda $380,x
  sta $360,x
  lda $3a0,x
  sta $380,x
  lda $3c0,x
  sta $3a0,x
  lda $3e0,x
  sta $3c0,x
  lda $400,x
  sta $3e0,x
  
  lda $420,x
  sta $400,x
  lda $440,x
  sta $420,x
  lda $460,x
  sta $440,x
  lda $480,x
  sta $460,x
  lda $4a0,x
  sta $480,x
  lda $4c0,x
  sta $4a0,x
  lda $4e0,x
  sta $4c0,x
  lda $500,x
  sta $4e0,x
  
  lda $520,x
  sta $500,x
  lda $540,x
  sta $520,x
  lda $560,x
  sta $540,x
  lda $580,x
  sta $560,x
  lda $5a0,x
  sta $580,x
  lda $5c0,x
  sta $5a0,x
  lda $5e0,x
  sta $5c0,x
 
  ; 4-line off-screen buffer
  lda $600,x 
  sta $5e0,x
  lda $620,x
  sta $600,x
  lda $640,x
  sta $620,x
  lda $660,x
  sta $640,x
  lda #0      ; erase 4th line
  sta $660,x

  dex 
  bmi scycq
  jmp scyc
scycq:
  rts

delay: ;---------------------------------------

; remark: align to your machine/taste

dlyx:
  ldy $d0
dlyy:  
  dey
  bne dlyy
  dex
  bne dlyx
  rts

gdelay:
  rts  ; yep
  ldx $d1 
  jmp delay

cdelay:
  ldx $d2
  jmp delay

